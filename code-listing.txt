ЛИСТИНГ КОДА ПРОЕКТА
Дата создания: 23.12.2025, 01:25:53
Всего файлов: 157
================================================================================

.vscode/settings.json
{
"editor.formatOnSave": true,
"[html]": {
"editor.defaultFormatter": "esbenp.prettier-vscode"
},
"[css]": {
"editor.defaultFormatter": "esbenp.prettier-vscode"
},
"[javascript]": {
"editor.defaultFormatter": "esbenp.prettier-vscode"
},
"[typescript]": {
"editor.defaultFormatter": "esbenp.prettier-vscode"
},
"[typescriptreact]": {
"editor.defaultFormatter": "esbenp.prettier-vscode"
},
"[java]": {
"editor.defaultFormatter": "redhat.java"
}
}

.vscode/tasks.json
{
"version": "2.0.0",
"tasks": [
{
"label": "Maven: Запуск (dev)",
"type": "shell",
"command": "mvn spring-boot:run -Pdev",
"options": {
"cwd": "${workspaceFolder}/calendar",
"env": {
"SPRING_PROFILES_ACTIVE": "dev",
"JWT_SECRET": "${env:JWT_SECRET:your-256-bit-secret-key-for-jwt-token-generation-minimum-32-characters}"
}
},
"problemMatcher": "$tsc",
"group": {
"kind": "build",
"isDefault": false
},
"presentation": {
"reveal": "always",
"panel": "new"
},
"isBackground": true
},
{
"label": "Maven: Запуск (prod)",
"type": "shell",
"command": "mvn spring-boot:run -Pprod",
"options": {
"cwd": "${workspaceFolder}/calendar",
"env": {
"SPRING_PROFILES_ACTIVE": "prod",
"JWT_SECRET": "${env:JWT_SECRET:your-256-bit-secret-key-for-jwt-token-generation-minimum-32-characters}"
}
},
"problemMatcher": "$tsc",
"group": {
"kind": "build",
"isDefault": false
},
"presentation": {
"reveal": "always",
"panel": "new"
},
"isBackground": true
},
{
"label": "Maven: Запуск (nopass)",
"type": "shell",
"command": "mvn spring-boot:run -Pnopass",
"options": {
"cwd": "${workspaceFolder}/calendar",
"env": {
"SPRING_PROFILES_ACTIVE": "nopass",
"JWT_SECRET": "${env:JWT_SECRET:your-256-bit-secret-key-for-jwt-token-generation-minimum-32-characters}"
}
},
"problemMatcher": "$tsc",
"group": {
"kind": "build",
"isDefault": false
},
"presentation": {
"reveal": "always",
"panel": "new"
},
"isBackground": true
},
{
"label": "Maven: Сборка (front)",
"type": "shell",
"command": "mvn clean package -Pfront -DskipTests",
"options": {
"cwd": "${workspaceFolder}/calendar"
},
"problemMatcher": "$tsc",
"group": {
"kind": "build",
"isDefault": false
},
"presentation": {
"reveal": "always",
"panel": "new"
}
},
{
"label": "Docker: Запуск PostgreSQL",
"type": "shell",
"command": "docker-compose up -d",
"options": {
"cwd": "${workspaceFolder}"
},
"problemMatcher": [],
"group": {
"kind": "build",
"isDefault": false
},
"presentation": {
"reveal": "always",
"panel": "new"
}
},
{
"label": "Docker: Остановка PostgreSQL",
"type": "shell",
"command": "docker-compose down",
"options": {
"cwd": "${workspaceFolder}"
},
"problemMatcher": [],
"group": {
"kind": "build",
"isDefault": false
},
"presentation": {
"reveal": "always",
"panel": "new"
}
},
{
"label": "Docker: Остановка PostgreSQL (с удалением данных)",
"type": "shell",
"command": "docker-compose down -v",
"options": {
"cwd": "${workspaceFolder}"
},
"problemMatcher": [],
"group": {
"kind": "build",
"isDefault": false
},
"presentation": {
"reveal": "always",
"panel": "new"
}
},
{
"label": "Docker: Просмотр логов PostgreSQL",
"type": "shell",
"command": "docker-compose logs -f postgres",
"options": {
"cwd": "${workspaceFolder}"
},
"problemMatcher": [],
"group": {
"kind": "build",
"isDefault": false
},
"presentation": {
"reveal": "always",
"panel": "new"
},
"isBackground": true
},
{
"label": "Liquibase: Применить миграции (prod)",
"type": "shell",
"command": "mvn liquibase:update -Pprod",
"options": {
"cwd": "${workspaceFolder}/calendar"
},
"problemMatcher": [],
"group": {
"kind": "build",
"isDefault": false
},
"presentation": {
"reveal": "always",
"panel": "new"
}
},
{
"label": "Liquibase: Статус миграций (prod)",
"type": "shell",
"command": "mvn liquibase:status -Pprod",
"options": {
"cwd": "${workspaceFolder}/calendar"
},
"problemMatcher": [],
"group": {
"kind": "build",
"isDefault": false
},
"presentation": {
"reveal": "always",
"panel": "new"
}
},
{
"label": "Liquibase: Откатить последнюю миграцию (prod)",
"type": "shell",
"command": "mvn liquibase:rollback -Pprod -Dliquibase.rollbackCount=1",
"options": {
"cwd": "${workspaceFolder}/calendar"
},
"problemMatcher": [],
"group": {
"kind": "build",
"isDefault": false
},
"presentation": {
"reveal": "always",
"panel": "new"
}
},
{
"label": "Maven: Запуск JAR (front+prod)",
"type": "shell",
"command": "java -jar target/calendar-0.0.1-SNAPSHOT.jar",
"options": {
"cwd": "${workspaceFolder}/calendar",
"shell": {
"executable": "cmd.exe",
"args": ["/c"]
},
"env": {
"SPRING_PROFILES_ACTIVE": "prod",
"JWT_SECRET": "${env:JWT_SECRET:your-256-bit-secret-key-for-jwt-token-generation-minimum-32-characters}",
"DB_USERNAME": "${env:DB_USERNAME:postgres}",
"DB_PASSWORD": "${env:DB_PASSWORD:postgres}"
}
},
"problemMatcher": [],
"group": {
"kind": "build",
"isDefault": false
},
"presentation": {
"reveal": "always",
"panel": "new"
},
"isBackground": true,
"dependsOn": "Maven: Сборка (front)"
}
]
}

calendar/.mvn/wrapper/maven-wrapper.properties
wrapperVersion=3.3.4
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.12/apache-maven-3.9.12-bin.zip

calendar/pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion>
<parent>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-parent</artifactId>
<version>4.0.1</version>
<relativePath /> <!-- lookup parent from repository -->
</parent>
<groupId>com.coursework</groupId>
<artifactId>calendar</artifactId>
<version>0.0.1-SNAPSHOT</version>
<name>calendar</name>
<description>internet programming course work</description>
<url />
<licenses>
<license />
</licenses>
<developers>
<developer />
</developers>
<scm>
<connection />
<developerConnection />
<tag />
<url />
</scm>
<properties>
<java.version>21</java.version>
<node.version>v20.18.0</node.version>
<npm.version>10.2.4</npm.version>
<liquibase.db.username>postgres</liquibase.db.username>
<liquibase.db.password>postgres</liquibase.db.password>
</properties>
<dependencies>
<!-- Spring Boot Web -->
<dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-web</artifactId>
</dependency>
<!-- Spring Boot Data JPA -->
<dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<!-- Spring Boot Security -->
<dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-security</artifactId>
</dependency>
<!-- Spring Boot Validation -->
<dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-validation</artifactId>
</dependency>
<!-- Liquibase для миграций БД -->
<dependency>
<groupId>org.liquibase</groupId>
<artifactId>liquibase-core</artifactId>
</dependency>
<!-- H2 Database -->
<dependency>
<groupId>com.h2database</groupId>
<artifactId>h2</artifactId>
<scope>runtime</scope>
</dependency>
<!-- PostgreSQL Driver -->
<dependency>
<groupId>org.postgresql</groupId>
<artifactId>postgresql</artifactId>
<scope>runtime</scope>
</dependency>
<!-- Spring Boot Test -->
<dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-test</artifactId>
<scope>test</scope>
</dependency>
<!-- Spring Security Test -->
<dependency>
<groupId>org.springframework.security</groupId>
<artifactId>spring-security-test</artifactId>
<scope>test</scope>
</dependency>
<!-- SpringDoc OpenAPI (Swagger) -->
<dependency>
<groupId>org.springdoc</groupId>
<artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
<version>2.6.0</version>
</dependency>
<!-- JWT -->
<dependency>
<groupId>io.jsonwebtoken</groupId>
<artifactId>jjwt-api</artifactId>
<version>0.12.5</version>
</dependency>
<dependency>
<groupId>io.jsonwebtoken</groupId>
<artifactId>jjwt-impl</artifactId>
<version>0.12.5</version>
<scope>runtime</scope>
</dependency>
<dependency>
<groupId>io.jsonwebtoken</groupId>
<artifactId>jjwt-jackson</artifactId>
<version>0.12.5</version>
<scope>runtime</scope>
</dependency>
</dependencies>
<build>
<plugins>
<plugin>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-maven-plugin</artifactId>
</plugin>
<plugin>
<groupId>org.liquibase</groupId>
<artifactId>liquibase-maven-plugin</artifactId>
<version>4.24.0</version>
<configuration>
<changeLogFile>src/main/resources/db/changelog/db.changelog-master.xml</changeLogFile>
<url>jdbc:postgresql://localhost:5432/calendardb</url>
<username>${liquibase.db.username}</username>
<password>${liquibase.db.password}</password>
<driver>org.postgresql.Driver</driver>
</configuration>
</plugin>
</plugins>
</build>
<profiles>
<!-- Профиль для разработки с H2 БД -->
<profile>
<id>dev</id>
<activation>
<activeByDefault>true</activeByDefault>
</activation>
<properties>
<spring.profiles.active>dev</spring.profiles.active>
</properties>
</profile>
<!-- Профиль для продакшена с PostgreSQL -->
<profile>
<id>prod</id>
<properties>
<spring.profiles.active>prod</spring.profiles.active>
</properties>
<build>
<plugins>
<plugin>
<groupId>org.codehaus.mojo</groupId>
<artifactId>properties-maven-plugin</artifactId>
<version>1.2.1</version>
<executions>
<execution>
<phase>initialize</phase>
<goals>
<goal>set-system-properties</goal>
</goals>
<configuration>
<properties>
<property>
<name>liquibase.db.username</name>
<value>${env.DB_USERNAME}</value>
</property>
<property>
<name>liquibase.db.password</name>
<value>${env.DB_PASSWORD}</value>
</property>
</properties>
<skipEmptyValues>true</skipEmptyValues>
</configuration>
</execution>
</executions>
</plugin>
</plugins>
</build>
</profile>
<!-- Профиль для сборки фронтенда в jar -->
<profile>
<id>front</id>
<build>
<plugins>
<plugin>
<groupId>com.github.eirslett</groupId>
<artifactId>frontend-maven-plugin</artifactId>
<version>1.15.0</version>
<configuration>
<workingDirectory>../frontend</workingDirectory>
<installDirectory>target</installDirectory>
</configuration>
<executions>
<execution>
<id>install node and npm</id>
<goals>
<goal>install-node-and-npm</goal>
</goals>
<configuration>
<nodeVersion>${node.version}</nodeVersion>
<npmVersion>${npm.version}</npmVersion>
</configuration>
</execution>
<execution>
<id>npm install</id>
<goals>
<goal>npm</goal>
</goals>
<configuration>
<arguments>install</arguments>
</configuration>
</execution>
<execution>
<id>npm run build</id>
<goals>
<goal>npm</goal>
</goals>
<configuration>
<arguments>run build</arguments>
</configuration>
</execution>
</executions>
</plugin>
<plugin>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-maven-plugin</artifactId>
<configuration>
<addResources>true</addResources>
</configuration>
</plugin>
</plugins>
<resources>
<resource>
<directory>src/main/resources</directory>
</resource>
<resource>
<directory>../frontend/dist</directory>
<targetPath>static</targetPath>
</resource>
</resources>
</build>
</profile>
<!-- Профиль для беспарольного доступа (отключение безопасности) -->
<profile>
<id>nopass</id>
<properties>
<spring.profiles.active>nopass</spring.profiles.active>
</properties>
</profile>
</profiles>
</project>

calendar/src/main/java/com/coursework/calendar/api/contact/ContactController.java
package com.coursework.calendar.api.contact;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;
import jakarta.validation.Valid;
import com.coursework.calendar.api.contact.dto.ContactRequestResponse;
import com.coursework.calendar.api.contact.dto.ContactRequestRs;
import com.coursework.calendar.mapper.ContactMapper;
import com.coursework.calendar.service.ContactService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
@RestController
@RequestMapping("/api/contacts")
@Tag(name = "Контакты", description = "API для управления запросами на добавление в контакты")
public class ContactController {
private final ContactService contactService;
public ContactController(ContactService contactService) {
this.contactService = contactService;
}
@GetMapping
@Operation(summary = "Получить все запросы на контакты", description = "Возвращает список всех запросов на добавление в контакты")
@ApiResponse(responseCode = "200", description = "Успешное получение списка запросов",
content = @Content(schema = @Schema(implementation = ContactRequestResponse.class)))
public List<ContactRequestResponse> getAllContactRequests() {
return contactService.getAllContactRequests().stream()
.map(ContactMapper::toResponse)
.collect(Collectors.toList());
}
@GetMapping("/{id}")
@Operation(summary = "Получить запрос на контакт по ID", description = "Возвращает запрос на добавление в контакты по указанному идентификатору")
@ApiResponses(value = {
@ApiResponse(responseCode = "200", description = "Запрос найден",
content = @Content(schema = @Schema(implementation = ContactRequestResponse.class))),
@ApiResponse(responseCode = "404", description = "Запрос не найден")
})
public ContactRequestResponse getContactRequestById(
@Parameter(description = "Идентификатор запроса", required = true) @PathVariable UUID id) {
return ContactMapper.toResponse(contactService.getContactRequestById(id));
}
@GetMapping("/user/{userId}")
@Operation(summary = "Получить запросы на контакты пользователя", description = "Возвращает все запросы на добавление в контакты для указанного пользователя")
@ApiResponse(responseCode = "200", description = "Успешное получение запросов пользователя",
content = @Content(schema = @Schema(implementation = ContactRequestResponse.class)))
public List<ContactRequestResponse> getContactRequestsByUserId(
@Parameter(description = "Идентификатор пользователя", required = true) @PathVariable UUID userId) {
return contactService.getContactRequestsByUserId(userId).stream()
.map(ContactMapper::toResponse)
.collect(Collectors.toList());
}
@PostMapping
@Operation(summary = "Создать запрос на контакт", description = "Создает новый запрос на добавление в контакты")
@ApiResponses(value = {
@ApiResponse(responseCode = "201", description = "Запрос успешно создан",
content = @Content(schema = @Schema(implementation = ContactRequestResponse.class))),
@ApiResponse(responseCode = "400", description = "Некорректные данные запроса"),
@ApiResponse(responseCode = "409", description = "Запрос уже существует между этими пользователями")
})
@ResponseStatus(HttpStatus.CREATED)
public ContactRequestResponse createContactRequest(
@Parameter(description = "Данные запроса на контакт", required = true) @Valid @RequestBody ContactRequestRs contactRequestRs) {
try {
return ContactMapper.toResponse(contactService.createContactRequest(ContactMapper.toEntity(contactRequestRs)));
} catch (IllegalStateException e) {
throw new org.springframework.web.server.ResponseStatusException(HttpStatus.CONFLICT, e.getMessage());
} catch (IllegalArgumentException e) {
throw new org.springframework.web.server.ResponseStatusException(HttpStatus.BAD_REQUEST, e.getMessage());
}
}
@PutMapping("/{id}")
@Operation(summary = "Обновить запрос на контакт", description = "Обновляет существующий запрос на добавление в контакты")
@ApiResponses(value = {
@ApiResponse(responseCode = "200", description = "Запрос успешно обновлен",
content = @Content(schema = @Schema(implementation = ContactRequestResponse.class))),
@ApiResponse(responseCode = "404", description = "Запрос не найден"),
@ApiResponse(responseCode = "400", description = "Некорректные данные запроса")
})
public ContactRequestResponse updateContactRequest(
@Parameter(description = "Идентификатор запроса", required = true) @PathVariable UUID id,
@Parameter(description = "Обновленные данные запроса", required = true) @Valid @RequestBody ContactRequestRs contactRequestRs) {
return ContactMapper
.toResponse(contactService.updateContactRequest(id, ContactMapper.toEntity(contactRequestRs)));
}
@DeleteMapping("/{id}")
@Operation(summary = "Удалить запрос на контакт", description = "Удаляет запрос на добавление в контакты по указанному идентификатору")
@ApiResponses(value = {
@ApiResponse(responseCode = "204", description = "Запрос успешно удален"),
@ApiResponse(responseCode = "404", description = "Запрос не найден")
})
@ResponseStatus(HttpStatus.NO_CONTENT)
public void deleteContactRequest(
@Parameter(description = "Идентификатор запроса", required = true) @PathVariable UUID id) {
contactService.deleteContactRequest(id);
}
}

calendar/src/main/java/com/coursework/calendar/api/contact/dto/ContactRequestResponse.java
package com.coursework.calendar.api.contact.dto;
import java.time.LocalDateTime;
import java.util.Optional;
import java.util.UUID;
import com.coursework.calendar.entities.contact.ContactRequestStatus;
public record ContactRequestResponse(UUID id, LocalDateTime createdAt, Optional<LocalDateTime> respondedAt,
UUID fromUserId,
UUID toUserId, ContactRequestStatus status) {
}

calendar/src/main/java/com/coursework/calendar/api/contact/dto/ContactRequestRs.java
package com.coursework.calendar.api.contact.dto;
import java.time.LocalDateTime;
import java.util.Optional;
import java.util.UUID;
import com.coursework.calendar.entities.contact.ContactRequestStatus;
import jakarta.validation.constraints.NotNull;
public record ContactRequestRs(
LocalDateTime createdAt,
Optional<LocalDateTime> respondedAt,
@NotNull(message = "ID отправителя обязателен") UUID fromUserId,
@NotNull(message = "ID получателя обязателен") UUID toUserId,
@NotNull(message = "Статус запроса обязателен") ContactRequestStatus status) {
}

calendar/src/main/java/com/coursework/calendar/api/event/dto/EventRequest.java
package com.coursework.calendar.api.event.dto;
import java.time.LocalDateTime;
import java.util.UUID;
import com.coursework.calendar.entities.event.EventStatus;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
@ValidEventTime
public record EventRequest(
@NotBlank(message = "Название события обязательно") String title,
@NotBlank(message = "Описание события обязательно") String description,
@NotNull(message = "Дата начала события обязательна") LocalDateTime startTime,
@NotNull(message = "Дата окончания события обязательна") LocalDateTime endTime,
@NotNull(message = "ID владельца обязателен") UUID ownerId,
@NotNull(message = "Статус события обязателен") EventStatus status) {
}

calendar/src/main/java/com/coursework/calendar/api/event/dto/EventResponse.java
package com.coursework.calendar.api.event.dto;
import java.time.LocalDateTime;
import java.util.UUID;
import com.coursework.calendar.entities.event.EventStatus;
public record EventResponse(UUID id, String title, String description, LocalDateTime startTime, LocalDateTime endTime,
UUID ownerId, LocalDateTime createdAt, EventStatus status) {
}

calendar/src/main/java/com/coursework/calendar/api/event/dto/EventTimeValidator.java
package com.coursework.calendar.api.event.dto;
import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;
public class EventTimeValidator implements ConstraintValidator<ValidEventTime, EventRequest> {
@Override
public void initialize(ValidEventTime constraintAnnotation) {
}
@Override
public boolean isValid(EventRequest eventRequest, ConstraintValidatorContext context) {
if (eventRequest.startTime() == null || eventRequest.endTime() == null) {
return true; // @NotNull уже проверит это
}
return !eventRequest.endTime().isBefore(eventRequest.startTime());
}
}

calendar/src/main/java/com/coursework/calendar/api/event/dto/ValidEventTime.java
package com.coursework.calendar.api.event.dto;
import jakarta.validation.Constraint;
import jakarta.validation.Payload;
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Target({ ElementType.TYPE })
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = EventTimeValidator.class)
@Documented
public @interface ValidEventTime {
String message() default "Время окончания события не может быть раньше времени начала";
Class<?>[] groups() default {};
Class<? extends Payload>[] payload() default {};
}

calendar/src/main/java/com/coursework/calendar/api/event/EventController.java
package com.coursework.calendar.api.event;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;
import jakarta.validation.Valid;
import com.coursework.calendar.api.event.dto.EventRequest;
import com.coursework.calendar.api.event.dto.EventResponse;
import com.coursework.calendar.mapper.EventMapper;
import com.coursework.calendar.service.EventService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
@RestController
@RequestMapping("/api/events")
@Tag(name = "События", description = "API для управления событиями календаря")
public class EventController {
private final EventService eventService;
public EventController(EventService eventService) {
this.eventService = eventService;
}
@GetMapping
@Operation(summary = "Получить все события", description = "Возвращает список всех событий")
@ApiResponse(responseCode = "200", description = "Успешное получение списка событий", content = @Content(schema = @Schema(implementation = EventResponse.class)))
public List<EventResponse> getAllEvents() {
return eventService.getAllEvents().stream()
.map(EventMapper::toResponse)
.collect(Collectors.toList());
}
@GetMapping("/user/{userId}")
@Operation(summary = "Получить все события пользователя", description = "Возвращает список всех событий пользователя")
@ApiResponse(responseCode = "200", description = "Успешное получение списка событий пользователя", content = @Content(schema = @Schema(implementation = EventResponse.class)))
public List<EventResponse> getUserEvents(@PathVariable UUID userId) {
return eventService.getEventsByUserId(userId).stream()
.map(EventMapper::toResponse)
.collect(Collectors.toList());
}
@GetMapping("/invited/{userId}")
@Operation(summary = "Получить события, на которые пользователя пригласили", description = "Возвращает список событий, на которые указанный пользователь был приглашен")
@ApiResponse(responseCode = "200", description = "Успешное получение списка приглашенных событий", content = @Content(schema = @Schema(implementation = EventResponse.class)))
public List<EventResponse> getInvitedEvents(@PathVariable UUID userId) {
return eventService.getInvitedEventsByUserId(userId).stream()
.map(EventMapper::toResponse)
.collect(Collectors.toList());
}
@GetMapping("/{id}")
@Operation(summary = "Получить событие по ID", description = "Возвращает событие по указанному идентификатору")
@ApiResponses(value = {
@ApiResponse(responseCode = "200", description = "Событие найдено", content = @Content(schema = @Schema(implementation = EventResponse.class))),
@ApiResponse(responseCode = "404", description = "Событие не найдено")
})
public EventResponse getEventById(
@Parameter(description = "Идентификатор события", required = true) @PathVariable UUID id) {
return EventMapper.toResponse(eventService.getEventById(id));
}
@PostMapping
@Operation(summary = "Создать событие", description = "Создает новое событие в календаре")
@ApiResponses(value = {
@ApiResponse(responseCode = "201", description = "Событие успешно создано", content = @Content(schema = @Schema(implementation = EventResponse.class))),
@ApiResponse(responseCode = "400", description = "Некорректные данные запроса")
})
@ResponseStatus(HttpStatus.CREATED)
public EventResponse createEvent(
@Parameter(description = "Данные события", required = true) @Valid @RequestBody EventRequest eventRequest) {
return EventMapper.toResponse(eventService.createEvent(EventMapper.toEntity(eventRequest)));
}
@PutMapping("/{id}")
@Operation(summary = "Обновить событие", description = "Обновляет существующее событие")
@ApiResponses(value = {
@ApiResponse(responseCode = "200", description = "Событие успешно обновлено", content = @Content(schema = @Schema(implementation = EventResponse.class))),
@ApiResponse(responseCode = "404", description = "Событие не найдено"),
@ApiResponse(responseCode = "400", description = "Некорректные данные запроса")
})
public EventResponse updateEvent(
@Parameter(description = "Идентификатор события", required = true) @PathVariable UUID id,
@Parameter(description = "Обновленные данные события", required = true) @Valid @RequestBody EventRequest eventRequest) {
return EventMapper.toResponse(eventService.updateEvent(id, EventMapper.toEntity(eventRequest)));
}
@DeleteMapping("/{id}")
@Operation(summary = "Удалить событие", description = "Удаляет событие по указанному идентификатору")
@ApiResponses(value = {
@ApiResponse(responseCode = "204", description = "Событие успешно удалено"),
@ApiResponse(responseCode = "404", description = "Событие не найдено")
})
@ResponseStatus(HttpStatus.NO_CONTENT)
public void deleteEvent(
@Parameter(description = "Идентификатор события", required = true) @PathVariable UUID id) {
eventService.deleteEvent(id);
}
}

calendar/src/main/java/com/coursework/calendar/api/invitation/dto/InvitationRequest.java
package com.coursework.calendar.api.invitation.dto;
import java.util.UUID;
import com.coursework.calendar.entities.invitation.InvitationStatus;
import jakarta.validation.constraints.NotNull;
public record InvitationRequest(
@NotNull(message = "ID события обязателен") UUID eventId,
@NotNull(message = "ID пользователя обязателен") UUID userId,
@NotNull(message = "Статус приглашения обязателен") InvitationStatus status) {
}

calendar/src/main/java/com/coursework/calendar/api/invitation/dto/InvitationResponse.java
package com.coursework.calendar.api.invitation.dto;
import java.time.LocalDateTime;
import java.util.UUID;
import com.coursework.calendar.entities.invitation.InvitationStatus;
public record InvitationResponse(UUID id, UUID eventId, UUID userId, LocalDateTime createdAt, InvitationStatus status) {
}

calendar/src/main/java/com/coursework/calendar/api/invitation/InvitationController.java
package com.coursework.calendar.api.invitation;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;
import jakarta.validation.Valid;
import com.coursework.calendar.api.invitation.dto.InvitationRequest;
import com.coursework.calendar.api.invitation.dto.InvitationResponse;
import com.coursework.calendar.mapper.InvitationMapper;
import com.coursework.calendar.service.InvitationService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
@RestController
@RequestMapping("/api/invitations")
@Tag(name = "Приглашения", description = "API для управления приглашениями на события")
public class InvitationController {
private final InvitationService invitationService;
public InvitationController(InvitationService invitationService) {
this.invitationService = invitationService;
}
@GetMapping
@Operation(summary = "Получить все приглашения", description = "Возвращает список всех приглашений")
@ApiResponse(responseCode = "200", description = "Успешное получение списка приглашений", content = @Content(schema = @Schema(implementation = InvitationResponse.class)))
public List<InvitationResponse> getAllInvitations() {
return invitationService.getAllInvitations().stream()
.map(InvitationMapper::toResponse)
.collect(Collectors.toList());
}
@GetMapping("/{id}")
@Operation(summary = "Получить приглашение по ID", description = "Возвращает приглашение по указанному идентификатору")
@ApiResponses(value = {
@ApiResponse(responseCode = "200", description = "Приглашение найдено", content = @Content(schema = @Schema(implementation = InvitationResponse.class))),
@ApiResponse(responseCode = "404", description = "Приглашение не найдено")
})
public InvitationResponse getInvitationById(
@Parameter(description = "Идентификатор приглашения", required = true) @PathVariable UUID id) {
return InvitationMapper.toResponse(invitationService.getInvitationById(id));
}
@GetMapping("/user/{userId}")
@Operation(summary = "Получить приглашения пользователя", description = "Возвращает все приглашения для указанного пользователя")
@ApiResponse(responseCode = "200", description = "Успешное получение приглашений пользователя", content = @Content(schema = @Schema(implementation = InvitationResponse.class)))
public List<InvitationResponse> getInvitationsByUserId(
@Parameter(description = "Идентификатор пользователя", required = true) @PathVariable UUID userId) {
return invitationService.getInvitationsByUserId(userId).stream()
.map(InvitationMapper::toResponse)
.collect(Collectors.toList());
}
@PostMapping
@Operation(summary = "Создать приглашение", description = "Создает новое приглашение на событие")
@ApiResponses(value = {
@ApiResponse(responseCode = "201", description = "Приглашение успешно создано", content = @Content(schema = @Schema(implementation = InvitationResponse.class))),
@ApiResponse(responseCode = "400", description = "Некорректные данные запроса")
})
@ResponseStatus(HttpStatus.CREATED)
public InvitationResponse createInvitation(
@Parameter(description = "Данные приглашения", required = true) @Valid @RequestBody InvitationRequest invitationRequest) {
return InvitationMapper
.toResponse(invitationService.createInvitation(InvitationMapper.toEntity(invitationRequest)));
}
@PutMapping("/{id}")
@Operation(summary = "Обновить приглашение", description = "Обновляет существующее приглашение")
@ApiResponses(value = {
@ApiResponse(responseCode = "200", description = "Приглашение успешно обновлено", content = @Content(schema = @Schema(implementation = InvitationResponse.class))),
@ApiResponse(responseCode = "404", description = "Приглашение не найдено"),
@ApiResponse(responseCode = "400", description = "Некорректные данные запроса")
})
public InvitationResponse updateInvitation(
@Parameter(description = "Идентификатор приглашения", required = true) @PathVariable UUID id,
@Parameter(description = "Обновленные данные приглашения", required = true) @Valid @RequestBody InvitationRequest invitationRequest) {
return InvitationMapper
.toResponse(invitationService.updateInvitation(id, InvitationMapper.toEntity(invitationRequest)));
}
@DeleteMapping("/{id}")
@Operation(summary = "Удалить приглашение", description = "Удаляет приглашение по указанному идентификатору")
@ApiResponses(value = {
@ApiResponse(responseCode = "204", description = "Приглашение успешно удалено"),
@ApiResponse(responseCode = "404", description = "Приглашение не найдено")
})
@ResponseStatus(HttpStatus.NO_CONTENT)
public void deleteInvitation(
@Parameter(description = "Идентификатор приглашения", required = true) @PathVariable UUID id) {
invitationService.deleteInvitation(id);
}
}

calendar/src/main/java/com/coursework/calendar/api/user/AuthController.java
package com.coursework.calendar.api.user;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.env.Environment;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.CookieValue;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import jakarta.validation.Valid;
import com.coursework.calendar.api.user.dto.AuthResponse;
import com.coursework.calendar.api.user.dto.UserCreateRequest;
import com.coursework.calendar.api.user.dto.UserLoginRequest;
import com.coursework.calendar.api.user.dto.UserResponse;
import com.coursework.calendar.entities.user.User;
import com.coursework.calendar.mapper.UserMapper;
import com.coursework.calendar.service.JwtService;
import com.coursework.calendar.service.UserService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletResponse;
@RestController
@RequestMapping("/api/auth")
@Tag(name = "Авторизация", description = "API для авторизации и регистрации пользователей")
public class AuthController {
private static final Logger logger = LoggerFactory.getLogger(AuthController.class);
private static final String DEFAULT_ADMIN_EMAIL = "admin@system.local";
private final UserService userService;
private final PasswordEncoder passwordEncoder;
private final JwtService jwtService;
private final Environment environment;
public AuthController(UserService userService, PasswordEncoder passwordEncoder, JwtService jwtService,
Environment environment) {
this.userService = userService;
this.passwordEncoder = passwordEncoder;
this.jwtService = jwtService;
this.environment = environment;
}
private boolean isNopassProfile() {
String[] activeProfiles = environment.getActiveProfiles();
for (String profile : activeProfiles) {
if ("nopass".equals(profile)) {
return true;
}
}
return false;
}
@PostMapping("/login")
@Operation(summary = "Авторизация пользователя", description = "Авторизует пользователя по email и паролю")
@ApiResponses(value = {
@ApiResponse(responseCode = "200", description = "Успешная авторизация", content = @Content(schema = @Schema(implementation = AuthResponse.class))),
@ApiResponse(responseCode = "401", description = "Неверный email или пароль")
})
public ResponseEntity<AuthResponse> login(@Valid @RequestBody UserLoginRequest userLoginRequest,
HttpServletResponse response) {
try {
User user = userService.getUserByEmail(userLoginRequest.email());
if (!passwordEncoder.matches(userLoginRequest.password(), user.getPasswordHash())) {
return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
}
String accessToken = jwtService.generateAccessToken(user);
String refreshToken = jwtService.generateRefreshToken(user);
Cookie refreshTokenCookie = new Cookie("refreshToken", refreshToken);
refreshTokenCookie.setHttpOnly(true);
refreshTokenCookie.setSecure(false); // В продакшене должно быть true для HTTPS
refreshTokenCookie.setPath("/");
refreshTokenCookie.setMaxAge(7 * 24 * 60 * 60); // 7 дней
response.addCookie(refreshTokenCookie);
AuthResponse authResponse = new AuthResponse(accessToken, user.getId(), user.getEmail(),
user.getUsername());
return ResponseEntity.ok(authResponse);
} catch (RuntimeException e) {
return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
}
}
@PostMapping("/register")
@Operation(summary = "Регистрация пользователя", description = "Регистрирует нового пользователя")
@ApiResponses(value = {
@ApiResponse(responseCode = "200", description = "Успешная регистрация"),
@ApiResponse(responseCode = "400", description = "Некорректные данные запроса"),
@ApiResponse(responseCode = "403", description = "Регистрация отключена в режиме nopass"),
@ApiResponse(responseCode = "409", description = "Пользователь уже существует")
})
public ResponseEntity<Void> register(@Valid @RequestBody UserCreateRequest userCreateRequest) {
// В профиле nopass регистрация отключена
if (isNopassProfile()) {
return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
}
try {
userService.getUserByEmail(userCreateRequest.email());
return ResponseEntity.status(HttpStatus.CONFLICT).build();
} catch (RuntimeException e) {
try {
userService.createUser(UserMapper.toEntity(userCreateRequest));
return ResponseEntity.ok().build();
} catch (Exception ex) {
return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
}
}
}
@PostMapping("/refresh")
@Operation(summary = "Обновление токена", description = "Обновляет access token используя refresh token из cookie")
@ApiResponses(value = {
@ApiResponse(responseCode = "200", description = "Токен успешно обновлен", content = @Content(schema = @Schema(implementation = AuthResponse.class))),
@ApiResponse(responseCode = "401", description = "Невалидный refresh token")
})
public ResponseEntity<AuthResponse> refresh(
@Parameter(description = "Refresh token из cookie") @CookieValue(value = "refreshToken", required = false) String refreshToken,
HttpServletResponse response) {
// В профиле nopass всегда возвращаем данные дефолтного админа
if (isNopassProfile()) {
try {
User adminUser = userService.getUserByEmail(DEFAULT_ADMIN_EMAIL);
String newAccessToken = jwtService.generateAccessToken(adminUser);
String newRefreshToken = jwtService.generateRefreshToken(adminUser);
Cookie refreshTokenCookie = new Cookie("refreshToken", newRefreshToken);
refreshTokenCookie.setHttpOnly(true);
refreshTokenCookie.setSecure(false);
refreshTokenCookie.setPath("/");
refreshTokenCookie.setMaxAge(7 * 24 * 60 * 60);
response.addCookie(refreshTokenCookie);
AuthResponse authResponse = new AuthResponse(newAccessToken, adminUser.getId(), adminUser.getEmail(),
adminUser.getUsername());
return ResponseEntity.ok(authResponse);
} catch (Exception e) {
logger.error("Error in refresh endpoint for nopass profile: {}", e.getMessage(), e);
return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
}
}
// Обычная логика для других профилей
if (refreshToken == null || !jwtService.validateRefreshToken(refreshToken)) {
return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
}
String email = jwtService.extractUsername(refreshToken);
User user = userService.getUserByEmail(email);
String newAccessToken = jwtService.generateAccessToken(user);
String newRefreshToken = jwtService.generateRefreshToken(user);
Cookie refreshTokenCookie = new Cookie("refreshToken", newRefreshToken);
refreshTokenCookie.setHttpOnly(true);
refreshTokenCookie.setSecure(false);
refreshTokenCookie.setPath("/");
refreshTokenCookie.setMaxAge(7 * 24 * 60 * 60);
response.addCookie(refreshTokenCookie);
AuthResponse authResponse = new AuthResponse(newAccessToken, user.getId(), user.getEmail(),
user.getUsername());
return ResponseEntity.ok(authResponse);
}
@PostMapping("/logout")
@Operation(summary = "Выход из системы", description = "Выходит из системы, удаляя refresh token из cookie")
@ApiResponses(value = {
@ApiResponse(responseCode = "200", description = "Успешный выход из системы"),
@ApiResponse(responseCode = "401", description = "Не авторизован")
})
public ResponseEntity<Void> logout(HttpServletResponse response) {
// Удаляем refresh token cookie, устанавливая его с пустым значением и MaxAge =
// 0
Cookie refreshTokenCookie = new Cookie("refreshToken", "");
refreshTokenCookie.setHttpOnly(true);
refreshTokenCookie.setSecure(false);
refreshTokenCookie.setPath("/");
refreshTokenCookie.setMaxAge(0); // Удаляем cookie
response.addCookie(refreshTokenCookie);
return ResponseEntity.ok().build();
}
@GetMapping("/me")
@Operation(summary = "Получить текущего пользователя", description = "Возвращает информацию о текущем аутентифицированном пользователе")
@ApiResponses(value = {
@ApiResponse(responseCode = "200", description = "Информация о пользователе", content = @Content(schema = @Schema(implementation = UserResponse.class))),
@ApiResponse(responseCode = "401", description = "Не авторизован")
})
public ResponseEntity<UserResponse> getCurrentUser() {
Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
if (authentication == null || !authentication.isAuthenticated()) {
return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
}
String email = authentication.getName();
User user = userService.getUserByEmail(email);
return ResponseEntity.ok(UserMapper.toResponse(user));
}
}

calendar/src/main/java/com/coursework/calendar/api/user/dto/AuthResponse.java
package com.coursework.calendar.api.user.dto;
import java.util.UUID;
public record AuthResponse(String accessToken, UUID userId, String email, String username) {
}

calendar/src/main/java/com/coursework/calendar/api/user/dto/UserCreateRequest.java
package com.coursework.calendar.api.user.dto;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
public record UserCreateRequest(
@NotBlank(message = "Email обязателен") @Email(message = "Введите корректный email") String email,
@NotBlank(message = "Имя пользователя обязательно") @Size(min = 3, message = "Имя пользователя должно быть не менее 3 символов") String username,
@NotBlank(message = "Пароль обязателен") @Size(min = 8, message = "Пароль должен быть не менее 8 символов") String password) {
}

calendar/src/main/java/com/coursework/calendar/api/user/dto/UserLoginRequest.java
package com.coursework.calendar.api.user.dto;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
public record UserLoginRequest(
@NotBlank(message = "Email обязателен") @Email(message = "Введите корректный email") String email,
@NotBlank(message = "Пароль обязателен") @Size(min = 8, message = "Пароль должен быть не менее 8 символов") String password) {
}

calendar/src/main/java/com/coursework/calendar/api/user/dto/UserResponse.java
package com.coursework.calendar.api.user.dto;
import java.time.LocalDateTime;
import java.util.UUID;
import com.coursework.calendar.entities.user.UserRole;
public record UserResponse(UUID id, String email, String username, LocalDateTime createdAt,
UserRole role) {
}

calendar/src/main/java/com/coursework/calendar/api/user/dto/UserUpdateRequest.java
package com.coursework.calendar.api.user.dto;
import com.coursework.calendar.entities.user.UserRole;
public record UserUpdateRequest(
String email,
String username,
String password,
UserRole role) {
}

calendar/src/main/java/com/coursework/calendar/api/user/UserController.java
package com.coursework.calendar.api.user;
import java.util.UUID;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;
import jakarta.validation.Valid;
import com.coursework.calendar.api.user.dto.UserResponse;
import com.coursework.calendar.api.user.dto.UserUpdateRequest;
import com.coursework.calendar.entities.user.User;
import com.coursework.calendar.mapper.UserMapper;
import com.coursework.calendar.service.UserService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
@RestController
@RequestMapping("/api/users")
@Tag(name = "Пользователи", description = "API для управления пользователями")
public class UserController {
private final UserService userService;
public UserController(UserService userService) {
this.userService = userService;
}
@GetMapping
@Operation(summary = "Получить всех пользователей", description = "Возвращает список всех пользователей")
@ApiResponse(responseCode = "200", description = "Успешное получение списка пользователей", content = @Content(schema = @Schema(implementation = UserResponse.class)))
public java.util.List<UserResponse> getAllUsers() {
return userService.getAllUsers().stream()
.map(UserMapper::toResponse)
.toList();
}
@GetMapping("/{id}")
@Operation(summary = "Получить пользователя по ID", description = "Возвращает пользователя по указанному идентификатору")
@ApiResponses(value = {
@ApiResponse(responseCode = "200", description = "Пользователь найден", content = @Content(schema = @Schema(implementation = UserResponse.class))),
@ApiResponse(responseCode = "404", description = "Пользователь не найден")
})
public UserResponse getUserById(
@Parameter(description = "Идентификатор пользователя", required = true) @PathVariable UUID id) {
return UserMapper.toResponse(userService.getUserById(id));
}
@PutMapping("/{id}")
@Operation(summary = "Обновить пользователя", description = "Обновляет существующего пользователя")
@ApiResponses(value = {
@ApiResponse(responseCode = "200", description = "Пользователь успешно обновлен", content = @Content(schema = @Schema(implementation = UserResponse.class))),
@ApiResponse(responseCode = "404", description = "Пользователь не найден"),
@ApiResponse(responseCode = "400", description = "Некорректные данные запроса")
})
public UserResponse updateUser(
@Parameter(description = "Идентификатор пользователя", required = true) @PathVariable UUID id,
@Parameter(description = "Обновленные данные пользователя", required = true) @Valid @RequestBody UserUpdateRequest userUpdateRequest) {
return UserMapper.toResponse(userService.updateUser(id, UserMapper.toEntity(id, userUpdateRequest)));
}
@DeleteMapping("/{id}")
@Operation(summary = "Удалить пользователя", description = "Удаляет пользователя по указанному идентификатору")
@ApiResponses(value = {
@ApiResponse(responseCode = "204", description = "Пользователь успешно удален"),
@ApiResponse(responseCode = "404", description = "Пользователь не найден")
})
@ResponseStatus(HttpStatus.NO_CONTENT)
public void deleteUser(
@Parameter(description = "Идентификатор пользователя", required = true) @PathVariable UUID id) {
userService.deleteUser(id);
}
@GetMapping("/search")
@Operation(summary = "Поиск пользователей", description = "Ищет пользователей по username или email с пагинацией")
@ApiResponses(value = {
@ApiResponse(responseCode = "200", description = "Успешный поиск", content = @Content(schema = @Schema(implementation = UserResponse.class)))
})
public Page<UserResponse> searchUsers(
@Parameter(description = "Поисковый запрос (username или email)", required = true) @RequestParam String q,
@PageableDefault(size = 20) Pageable pageable) {
Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
UUID currentUserId = null;
if (authentication != null && authentication.isAuthenticated()) {
try {
String email = authentication.getName();
User currentUser = userService.getUserByEmail(email);
currentUserId = currentUser.getId();
} catch (RuntimeException e) {
// Игнорируем, если пользователь не найден
}
}
return userService.searchUsers(q, currentUserId, pageable)
.map(UserMapper::toResponse);
}
}

calendar/src/main/java/com/coursework/calendar/CalendarApplication.java
package com.coursework.calendar;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
@SpringBootApplication
public class CalendarApplication {
public static void main(String[] args) {
SpringApplication.run(CalendarApplication.class, args);
}
}

calendar/src/main/java/com/coursework/calendar/config/JwtAuthenticationFilter.java
package com.coursework.calendar.config;
import java.io.IOException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;
import com.coursework.calendar.service.JwtService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
private final JwtService jwtService;
private final UserDetailsService userDetailsService;
public JwtAuthenticationFilter(JwtService jwtService, UserDetailsService userDetailsService) {
this.jwtService = jwtService;
this.userDetailsService = userDetailsService;
}
@Override
protected void doFilterInternal(
HttpServletRequest request,
HttpServletResponse response,
FilterChain filterChain) throws ServletException, IOException {
// Пропускаем статические ресурсы и публичные API без проверки JWT
String path = request.getRequestURI();
if (path.startsWith("/assets/") || path.endsWith(".js") || path.endsWith(".css")
|| path.endsWith(".ico") || path.endsWith(".png") || path.endsWith(".svg")
|| path.endsWith(".jpg") || path.endsWith(".jpeg") || path.endsWith(".gif")
|| path.endsWith(".woff") || path.endsWith(".woff2") || path.endsWith(".ttf")
|| path.endsWith(".eot") || path.equals("/index.html") || path.equals("/logo.png")
|| path.startsWith("/h2-console/")
|| path.startsWith("/swagger-ui/") || path.startsWith("/v3/api-docs/")) {
filterChain.doFilter(request, response);
return;
}
// Пропускаем только публичные эндпоинты авторизации (login, register, refresh,
// logout)
// /api/auth/me требует аутентификации, поэтому не пропускаем его
if (path.equals("/api/auth/login") || path.equals("/api/auth/register")
|| path.equals("/api/auth/refresh") || path.equals("/api/auth/logout")) {
filterChain.doFilter(request, response);
return;
}
final String authHeader = request.getHeader("Authorization");
if (authHeader == null || !authHeader.startsWith("Bearer ")) {
filterChain.doFilter(request, response);
return;
}
try {
final String jwt = authHeader.substring(7);
final String userEmail = jwtService.extractUsername(jwt);
if (userEmail != null && SecurityContextHolder.getContext().getAuthentication() == null) {
UserDetails userDetails = this.userDetailsService.loadUserByUsername(userEmail);
if (jwtService.validateToken(jwt, userDetails.getUsername())) {
UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
userDetails,
null,
userDetails.getAuthorities());
authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
SecurityContextHolder.getContext().setAuthentication(authToken);
}
}
} catch (Exception e) {
// Если токен невалидный, просто пропускаем запрос дальше
// Spring Security сам проверит, нужна ли аутентификация для этого эндпоинта
}
filterChain.doFilter(request, response);
}
}

calendar/src/main/java/com/coursework/calendar/config/NoPassAuthenticationFilter.java
package com.coursework.calendar.config;
import java.io.IOException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Profile;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
/**
* Фильтр для профиля nopass, который автоматически подставляет дефолтного
* администратора
* в SecurityContext для всех запросов.
* Дефолтный администратор: admin@system.local
*/
@Component
@Profile("nopass")
public class NoPassAuthenticationFilter extends OncePerRequestFilter {
private static final Logger logger = LoggerFactory.getLogger(NoPassAuthenticationFilter.class);
private static final String DEFAULT_ADMIN_EMAIL = "admin@system.local";
private final UserDetailsService userDetailsService;
public NoPassAuthenticationFilter(UserDetailsService userDetailsService) {
this.userDetailsService = userDetailsService;
}
@Override
protected void doFilterInternal(
HttpServletRequest request,
HttpServletResponse response,
FilterChain filterChain) throws ServletException, IOException {
// Пропускаем только login и logout без подстановки админа
// register будет заблокирован в контроллере
// /me и /refresh будут работать с дефолтным админом
String path = request.getRequestURI();
if (path.equals("/api/auth/login") || path.equals("/api/auth/logout")) {
filterChain.doFilter(request, response);
return;
}
// Если уже есть аутентификация, пропускаем
if (SecurityContextHolder.getContext().getAuthentication() != null) {
filterChain.doFilter(request, response);
return;
}
try {
// Загружаем дефолтного администратора
UserDetails userDetails = userDetailsService.loadUserByUsername(DEFAULT_ADMIN_EMAIL);
// Создаем токен аутентификации
UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
userDetails,
null,
userDetails.getAuthorities());
authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
// Устанавливаем аутентификацию в SecurityContext
SecurityContextHolder.getContext().setAuthentication(authToken);
logger.debug("Auto-authenticated as default admin: {}", DEFAULT_ADMIN_EMAIL);
} catch (UsernameNotFoundException e) {
logger.warn(
"Default admin user ({}) not found. Make sure migration 002-default-admin.xml has been executed. Requests may fail if authentication is required.",
DEFAULT_ADMIN_EMAIL);
// Продолжаем выполнение даже если пользователь не найден
// Это позволит запросам пройти, но они могут упасть на уровне контроллеров
} catch (Exception e) {
logger.error("Unexpected error while loading default admin user ({}): {}",
DEFAULT_ADMIN_EMAIL, e.getMessage(), e);
// Продолжаем выполнение даже при ошибке
}
filterChain.doFilter(request, response);
}
}

calendar/src/main/java/com/coursework/calendar/config/OpenApiConfig.java
package com.coursework.calendar.config;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
@Configuration
public class OpenApiConfig {
@Bean
public OpenAPI customOpenAPI() {
return new OpenAPI()
.info(new Info()
.title("Calendar API")
.version("1.0.0")
.description("API для управления календарем, событиями, приглашениями и контактами")
.contact(new Contact()
.name("Course Work"))
.license(new License()
.name("Apache 2.0")
.url("https://www.apache.org/licenses/LICENSE-2.0.html")));
}
}

calendar/src/main/java/com/coursework/calendar/config/SecurityConfig.java
package com.coursework.calendar.config;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.beans.factory.annotation.Autowired;
@Configuration
@EnableWebSecurity
public class SecurityConfig {
private final JwtAuthenticationFilter jwtAuthenticationFilter;
private NoPassAuthenticationFilter noPassAuthenticationFilter;
public SecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter) {
this.jwtAuthenticationFilter = jwtAuthenticationFilter;
}
@Autowired(required = false)
public void setNoPassAuthenticationFilter(NoPassAuthenticationFilter noPassAuthenticationFilter) {
this.noPassAuthenticationFilter = noPassAuthenticationFilter;
}
@Bean
public PasswordEncoder passwordEncoder() {
return new BCryptPasswordEncoder();
}
@Bean
public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
return config.getAuthenticationManager();
}
@Bean
@Profile("nopass")
public SecurityFilterChain securityFilterChainNoPass(HttpSecurity http,
org.springframework.web.cors.CorsConfigurationSource corsConfigurationSource) throws Exception {
http
.csrf(csrf -> csrf.disable())
.cors(cors -> cors.configurationSource(corsConfigurationSource))
.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
.authorizeHttpRequests(auth -> auth
.anyRequest().permitAll());
// Добавляем фильтр только если он существует (т.е. профиль nopass активен)
if (noPassAuthenticationFilter != null) {
http.addFilterBefore(noPassAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
}
return http.build();
}
@Bean
@Profile("!nopass")
public SecurityFilterChain securityFilterChainDefault(HttpSecurity http,
org.springframework.web.cors.CorsConfigurationSource corsConfigurationSource) throws Exception {
http
.csrf(csrf -> csrf.disable())
.cors(cors -> cors.configurationSource(corsConfigurationSource))
.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
.authorizeHttpRequests(auth -> auth
.requestMatchers("/assets/**").permitAll()
.requestMatchers("/*.js", "/*.css", "/*.ico", "/*.png", "/*.svg", "/*.jpg", "/*.jpeg", "/*.gif",
"/*.woff", "/*.woff2", "/*.ttf", "/*.eot")
.permitAll()
.requestMatchers("/logo.png", "/vite.svg", "/index.html").permitAll()
.requestMatchers("/api/auth/**").permitAll()
.requestMatchers("/h2-console/**").permitAll()
.requestMatchers("/swagger-ui/**", "/v3/api-docs/**", "/swagger-ui.html").permitAll()
.requestMatchers("/api/**").authenticated()
.anyRequest().permitAll())
.headers(headers -> headers.frameOptions(frameOptions -> frameOptions.sameOrigin()))
.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
return http.build();
}
}

calendar/src/main/java/com/coursework/calendar/config/SpaController.java
package com.coursework.calendar.config;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
@Controller
@Order(Ordered.LOWEST_PRECEDENCE)
public class SpaController {
/**
* Обработка всех не-API запросов для SPA
* Все запросы, которые не начинаются с /api и не являются статическими
* ресурсами, перенаправляются на index.html
* Используется LOWEST_PRECEDENCE, чтобы этот контроллер обрабатывал запросы в
* последнюю очередь
*/
@RequestMapping(value = {
"/",
"/login",
"/register",
"/profile",
"/events",
"/events/**",
"/invitations",
"/contacts",
"/admin/**"
})
public String index() {
return "forward:/index.html";
}
}

calendar/src/main/java/com/coursework/calendar/config/WebConfig.java
package com.coursework.calendar.config;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import java.util.Arrays;
import java.util.List;
@Configuration
public class WebConfig implements WebMvcConfigurer {
@Bean
public CorsConfigurationSource corsConfigurationSource() {
CorsConfiguration configuration = new CorsConfiguration();
configuration.setAllowedOriginPatterns(List.of("*"));
configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
configuration.setAllowedHeaders(List.of("*"));
configuration.setAllowCredentials(true);
configuration.setExposedHeaders(List.of("Authorization"));
UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
source.registerCorsConfiguration("/**", configuration);
return source;
}
@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
// Обработка статических ресурсов из classpath:/static/
// Spring Boot по умолчанию ищет ресурсы в classpath:/static/, но мы явно указываем для ясности
// Важно: не используем "/**", чтобы не перехватывать API запросы
registry.addResourceHandler("/assets/**")
.addResourceLocations("classpath:/static/assets/")
.resourceChain(false);
registry.addResourceHandler("/*.js", "/*.css", "/*.ico", "/*.png", "/*.svg", "/*.jpg", "/*.jpeg", "/*.gif", "/*.woff", "/*.woff2", "/*.ttf", "/*.eot")
.addResourceLocations("classpath:/static/")
.resourceChain(false);
registry.addResourceHandler("/logo.png", "/vite.svg", "/index.html")
.addResourceLocations("classpath:/static/")
.resourceChain(false);
}
}

calendar/src/main/java/com/coursework/calendar/entities/contact/ContactRequest.java
package com.coursework.calendar.entities.contact;
import java.time.LocalDateTime;
import java.util.Optional;
import java.util.UUID;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
@Entity
@Table(name = "contact_requests")
public class ContactRequest {
@Id
@GeneratedValue(strategy = GenerationType.UUID)
@Column(name = "id", columnDefinition = "UUID")
private UUID id;
@Column(name = "created_at", nullable = false)
private LocalDateTime createdAt;
@Column(name = "responded_at", nullable = true)
private LocalDateTime respondedAt;
@Column(name = "from_user_id", nullable = false, columnDefinition = "UUID")
private UUID fromUserId;
@Column(name = "to_user_id", nullable = false, columnDefinition = "UUID")
private UUID toUserId;
@Enumerated(EnumType.STRING)
@Column(name = "status", nullable = false, length = 50)
private ContactRequestStatus status;
// Конструктор без параметров для JPA
public ContactRequest() {
}
public ContactRequest(UUID id, LocalDateTime createdAt, LocalDateTime respondedAt, UUID fromUserId,
UUID toUserId, ContactRequestStatus status) {
this.id = id;
this.createdAt = createdAt;
this.respondedAt = respondedAt;
this.fromUserId = fromUserId;
this.toUserId = toUserId;
this.status = status;
}
public UUID getId() {
return this.id;
}
public void setId(UUID id) {
this.id = id;
}
public LocalDateTime getCreatedAt() {
return this.createdAt;
}
public void setCreatedAt(LocalDateTime createdAt) {
this.createdAt = createdAt;
}
public LocalDateTime getRespondedAt() {
return this.respondedAt;
}
public void setRespondedAt(LocalDateTime respondedAt) {
this.respondedAt = respondedAt;
}
public Optional<LocalDateTime> getRespondedAtOptional() {
return Optional.ofNullable(this.respondedAt);
}
public UUID getFromUserId() {
return this.fromUserId;
}
public void setFromUserId(UUID fromUserId) {
this.fromUserId = fromUserId;
}
public UUID getToUserId() {
return this.toUserId;
}
public void setToUserId(UUID toUserId) {
this.toUserId = toUserId;
}
public ContactRequestStatus getStatus() {
return this.status;
}
public void setStatus(ContactRequestStatus status) {
this.status = status;
}
}

calendar/src/main/java/com/coursework/calendar/entities/contact/ContactRequestStatus.java
package com.coursework.calendar.entities.contact;
public enum ContactRequestStatus {
PENDING,
ACCEPTED,
REJECTED;
}

calendar/src/main/java/com/coursework/calendar/entities/event/Event.java
package com.coursework.calendar.entities.event;
import java.time.LocalDateTime;
import java.util.UUID;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
@Entity
@Table(name = "events")
public class Event {
@Id
@GeneratedValue(strategy = GenerationType.UUID)
@Column(name = "id", columnDefinition = "UUID")
private UUID id;
@Column(name = "title", nullable = false, length = 255)
private String title;
@Column(name = "description", columnDefinition = "TEXT")
private String description;
@Column(name = "start_time", nullable = false)
private LocalDateTime startTime;
@Column(name = "end_time", nullable = false)
private LocalDateTime endTime;
@Column(name = "owner_id", nullable = false, columnDefinition = "UUID")
private UUID ownerId;
@Column(name = "created_at", nullable = false)
private LocalDateTime createdAt;
@Enumerated(EnumType.STRING)
@Column(name = "status", nullable = false, length = 50)
private EventStatus status;
// Конструктор без параметров для JPA
public Event() {
}
public Event(UUID id, String title, String description, LocalDateTime startTime, LocalDateTime endTime,
UUID ownerId, LocalDateTime createdAt, EventStatus status) {
this.id = id;
this.title = title;
this.description = description;
this.startTime = startTime;
this.endTime = endTime;
this.ownerId = ownerId;
this.createdAt = createdAt;
this.status = status;
}
public Event(String title, String description, LocalDateTime startTime, LocalDateTime endTime, UUID ownerId,
EventStatus status) {
this(UUID.randomUUID(), title, description, startTime, endTime, ownerId, LocalDateTime.now(), status);
}
public UUID getId() {
return this.id;
}
public String getTitle() {
return this.title;
}
public String getDescription() {
return this.description;
}
public LocalDateTime getStartTime() {
return this.startTime;
}
public LocalDateTime getEndTime() {
return this.endTime;
}
public UUID getOwnerId() {
return this.ownerId;
}
public LocalDateTime getCreatedAt() {
return this.createdAt;
}
public EventStatus getStatus() {
return this.status;
}
public void setId(UUID id) {
this.id = id;
}
public void setTitle(String title) {
this.title = title;
}
public void setDescription(String description) {
this.description = description;
}
public void setStartTime(LocalDateTime startTime) {
this.startTime = startTime;
}
public void setEndTime(LocalDateTime endTime) {
this.endTime = endTime;
}
public void setOwnerId(UUID ownerId) {
this.ownerId = ownerId;
}
public void setCreatedAt(LocalDateTime createdAt) {
this.createdAt = createdAt;
}
public void setStatus(EventStatus status) {
this.status = status;
}
}

calendar/src/main/java/com/coursework/calendar/entities/event/EventStatus.java
package com.coursework.calendar.entities.event;
public enum EventStatus {
DRAFT,
PUBLISHED,
CANCELLED;
}

calendar/src/main/java/com/coursework/calendar/entities/invitation/Invitation.java
package com.coursework.calendar.entities.invitation;
import java.time.LocalDateTime;
import java.util.UUID;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
@Entity
@Table(name = "invitations")
public class Invitation {
@Id
@GeneratedValue(strategy = GenerationType.UUID)
@Column(name = "id", columnDefinition = "UUID")
private UUID id;
@Column(name = "event_id", nullable = false, columnDefinition = "UUID")
private UUID eventId;
@Column(name = "user_id", nullable = false, columnDefinition = "UUID")
private UUID userId;
@Column(name = "created_at", nullable = false)
private LocalDateTime createdAt;
@Enumerated(EnumType.STRING)
@Column(name = "status", nullable = false, length = 50)
private InvitationStatus status;
// Конструктор без параметров для JPA
public Invitation() {
}
public Invitation(UUID id, UUID eventId, UUID userId, LocalDateTime createdAt, InvitationStatus status) {
this.id = id;
this.eventId = eventId;
this.userId = userId;
this.createdAt = createdAt;
this.status = status;
}
public Invitation(UUID eventId, UUID userId, InvitationStatus status) {
this(UUID.randomUUID(), eventId, userId, LocalDateTime.now(), status);
}
public UUID getId() {
return this.id;
}
public UUID getEventId() {
return this.eventId;
}
public UUID getUserId() {
return this.userId;
}
public LocalDateTime getCreatedAt() {
return this.createdAt;
}
public InvitationStatus getStatus() {
return this.status;
}
public void setId(UUID id) {
this.id = id;
}
public void setEventId(UUID eventId) {
this.eventId = eventId;
}
public void setUserId(UUID userId) {
this.userId = userId;
}
public void setCreatedAt(LocalDateTime createdAt) {
this.createdAt = createdAt;
}
public void setStatus(InvitationStatus status) {
this.status = status;
}
}

calendar/src/main/java/com/coursework/calendar/entities/invitation/InvitationStatus.java
package com.coursework.calendar.entities.invitation;
public enum InvitationStatus {
PENDING,
ACCEPTED,
REJECTED;
}

calendar/src/main/java/com/coursework/calendar/entities/user/User.java
package com.coursework.calendar.entities.user;
import java.time.LocalDateTime;
import java.util.UUID;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
@Entity
@Table(name = "users")
public class User {
@Id
@GeneratedValue(strategy = GenerationType.UUID)
@Column(name = "id", columnDefinition = "UUID")
private UUID id;
@Column(name = "username", nullable = false, unique = false, length = 255)
private String username;
@Column(name = "email", nullable = false, unique = true, length = 255)
private String email;
@Column(name = "created_at", nullable = false)
private LocalDateTime createdAt;
@Column(name = "password_hash", nullable = false, length = 255)
private String passwordHash;
@Enumerated(EnumType.STRING)
@Column(name = "role", nullable = false, length = 50)
private UserRole role;
// Конструктор без параметров для JPA
public User() {
}
public User(UUID id, String username, String email, LocalDateTime createdAt, String passwordHash, UserRole role) {
this.id = id;
this.username = username;
this.createdAt = createdAt;
this.passwordHash = passwordHash;
this.role = role;
this.email = email;
}
public User(UUID id, String email, String username, String passwordHash, UserRole role) {
this(id, username, email, LocalDateTime.now(), passwordHash, role);
}
public UUID getId() {
return this.id;
}
public String getUsername() {
return this.username;
}
public String getEmail() {
return this.email;
}
public void setEmail(String email) {
this.email = email;
}
public LocalDateTime getCreatedAt() {
return this.createdAt;
}
public void setId(UUID id) {
this.id = id;
}
public void setUsername(String username) {
this.username = username;
}
public void setCreatedAt(LocalDateTime createdAt) {
this.createdAt = createdAt;
}
public void setPasswordHash(String passwordHash) {
this.passwordHash = passwordHash;
}
public String getPasswordHash() {
return this.passwordHash;
}
public UserRole getRole() {
return this.role;
}
public void setRole(UserRole role) {
this.role = role;
}
}

calendar/src/main/java/com/coursework/calendar/entities/user/UserRole.java
package com.coursework.calendar.entities.user;
public enum UserRole {
ADMIN,
USER;
}

calendar/src/main/java/com/coursework/calendar/mapper/ContactMapper.java
package com.coursework.calendar.mapper;
import com.coursework.calendar.api.contact.dto.ContactRequestResponse;
import com.coursework.calendar.api.contact.dto.ContactRequestRs;
import com.coursework.calendar.entities.contact.ContactRequest;
public class ContactMapper {
public static ContactRequest toEntity(ContactRequestRs contactRequestRs) {
ContactRequest contactRequest = new ContactRequest();
contactRequest.setCreatedAt(contactRequestRs.createdAt());
contactRequest.setRespondedAt(contactRequestRs.respondedAt().orElse(null));
contactRequest.setFromUserId(contactRequestRs.fromUserId());
contactRequest.setToUserId(contactRequestRs.toUserId());
contactRequest.setStatus(contactRequestRs.status());
return contactRequest;
}
public static ContactRequestResponse toResponse(ContactRequest contactRequest) {
return new ContactRequestResponse(
contactRequest.getId(),
contactRequest.getCreatedAt(),
java.util.Optional.ofNullable(contactRequest.getRespondedAt()),
contactRequest.getFromUserId(),
contactRequest.getToUserId(),
contactRequest.getStatus());
}
}

calendar/src/main/java/com/coursework/calendar/mapper/EventMapper.java
package com.coursework.calendar.mapper;
import java.time.LocalDateTime;
import com.coursework.calendar.api.event.dto.EventRequest;
import com.coursework.calendar.api.event.dto.EventResponse;
import com.coursework.calendar.entities.event.Event;
public class EventMapper {
public static Event toEntity(EventRequest eventRequest) {
Event event = new Event();
event.setTitle(eventRequest.title());
event.setDescription(eventRequest.description());
event.setStartTime(eventRequest.startTime());
event.setEndTime(eventRequest.endTime());
event.setOwnerId(eventRequest.ownerId());
event.setStatus(eventRequest.status());
event.setCreatedAt(LocalDateTime.now());
return event;
}
public static EventResponse toResponse(Event event) {
return new EventResponse(event.getId(), event.getTitle(), event.getDescription(), event.getStartTime(),
event.getEndTime(), event.getOwnerId(), event.getCreatedAt(), event.getStatus());
}
}

calendar/src/main/java/com/coursework/calendar/mapper/InvitationMapper.java
package com.coursework.calendar.mapper;
import java.time.LocalDateTime;
import com.coursework.calendar.api.invitation.dto.InvitationRequest;
import com.coursework.calendar.api.invitation.dto.InvitationResponse;
import com.coursework.calendar.entities.invitation.Invitation;
public class InvitationMapper {
public static Invitation toEntity(InvitationRequest invitationRequest) {
Invitation invitation = new Invitation();
invitation.setEventId(invitationRequest.eventId());
invitation.setUserId(invitationRequest.userId());
invitation.setStatus(invitationRequest.status());
invitation.setCreatedAt(LocalDateTime.now());
return invitation;
}
public static InvitationResponse toResponse(Invitation invitation) {
return new InvitationResponse(invitation.getId(), invitation.getEventId(), invitation.getUserId(),
invitation.getCreatedAt(), invitation.getStatus());
}
}

calendar/src/main/java/com/coursework/calendar/mapper/UserMapper.java
package com.coursework.calendar.mapper;
import com.coursework.calendar.entities.user.User;
import com.coursework.calendar.entities.user.UserRole;
import com.coursework.calendar.api.user.dto.UserCreateRequest;
import com.coursework.calendar.api.user.dto.UserResponse;
import com.coursework.calendar.api.user.dto.UserUpdateRequest;
import java.util.UUID;
public class UserMapper {
public static User toEntity(UserCreateRequest userCreateRequest) {
User user = new User();
user.setEmail(userCreateRequest.email());
user.setUsername(userCreateRequest.username());
user.setPasswordHash(userCreateRequest.password());
user.setRole(UserRole.USER);
user.setCreatedAt(java.time.LocalDateTime.now());
return user;
}
public static User toEntity(UUID id, UserUpdateRequest userUpdateRequest) {
return new User(
id,
userUpdateRequest.email(),
userUpdateRequest.username(),
userUpdateRequest.password(),
userUpdateRequest.role() != null ? userUpdateRequest.role() : UserRole.USER);
}
public static UserResponse toResponse(User user) {
return new UserResponse(user.getId(), user.getEmail(), user.getUsername(), user.getCreatedAt(), user.getRole());
}
}

calendar/src/main/java/com/coursework/calendar/repository/ContactRepository.java
package com.coursework.calendar.repository;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import com.coursework.calendar.entities.contact.ContactRequest;
import com.coursework.calendar.entities.contact.ContactRequestStatus;
@Repository
public interface ContactRepository extends JpaRepository<ContactRequest, UUID> {
List<ContactRequest> findByFromUserId(UUID fromUserId);
List<ContactRequest> findByToUserId(UUID toUserId);
@Query("SELECT cr FROM ContactRequest cr WHERE " +
"((cr.fromUserId = :userId1 AND cr.toUserId = :userId2) OR " +
"(cr.fromUserId = :userId2 AND cr.toUserId = :userId1)) AND " +
"cr.status IN :statuses")
Optional<ContactRequest> findExistingRequest(
@Param("userId1") UUID userId1,
@Param("userId2") UUID userId2,
@Param("statuses") List<ContactRequestStatus> statuses);
}

calendar/src/main/java/com/coursework/calendar/repository/EventRepository.java
package com.coursework.calendar.repository;
import java.util.List;
import java.util.UUID;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import com.coursework.calendar.entities.event.Event;
@Repository
public interface EventRepository extends JpaRepository<Event, UUID> {
List<Event> findByOwnerId(UUID ownerId);
}

calendar/src/main/java/com/coursework/calendar/repository/InvitationRepository.java
package com.coursework.calendar.repository;
import java.util.List;
import java.util.UUID;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import com.coursework.calendar.entities.invitation.Invitation;
@Repository
public interface InvitationRepository extends JpaRepository<Invitation, UUID> {
List<Invitation> findByUserId(UUID userId);
boolean existsByEventIdAndUserId(UUID eventId, UUID userId);
}

calendar/src/main/java/com/coursework/calendar/repository/UserRepository.java
package com.coursework.calendar.repository;
import java.util.Optional;
import java.util.UUID;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import com.coursework.calendar.entities.user.User;
@Repository
public interface UserRepository extends JpaRepository<User, UUID> {
Optional<User> findByEmail(String email);
boolean existsByEmail(String email);
@Query("SELECT u FROM User u WHERE " +
"(LOWER(u.username) LIKE LOWER(CONCAT('%', :query, '%')) OR " +
"LOWER(u.email) LIKE LOWER(CONCAT('%', :query, '%'))) AND " +
"u.id != :excludeUserId")
Page<User> searchUsers(@Param("query") String query, @Param("excludeUserId") UUID excludeUserId, Pageable pageable);
}

calendar/src/main/java/com/coursework/calendar/service/ContactService.java
package com.coursework.calendar.service;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;
import org.springframework.stereotype.Service;
import com.coursework.calendar.entities.contact.ContactRequest;
import com.coursework.calendar.entities.contact.ContactRequestStatus;
import com.coursework.calendar.repository.ContactRepository;
@Service
public class ContactService {
private final ContactRepository contactRepository;
public ContactService(ContactRepository contactRepository) {
this.contactRepository = contactRepository;
}
public List<ContactRequest> getAllContactRequests() {
return contactRepository.findAll();
}
public List<ContactRequest> getContactRequestsByUserId(UUID userId) {
List<ContactRequest> fromUser = contactRepository.findByFromUserId(userId);
List<ContactRequest> toUser = contactRepository.findByToUserId(userId);
List<ContactRequest> result = new java.util.ArrayList<>(fromUser);
result.addAll(toUser);
return result;
}
public ContactRequest getContactRequestById(UUID id) {
return contactRepository.findById(id)
.orElseThrow(() -> new RuntimeException("Contact request not found"));
}
public ContactRequest createContactRequest(ContactRequest contactRequest) {
// Проверяем, существует ли уже запрос между этими пользователями
// Проверяем PENDING и ACCEPTED статусы
if (contactRepository.findExistingRequest(
contactRequest.getFromUserId(),
contactRequest.getToUserId(),
Arrays.asList(ContactRequestStatus.PENDING, ContactRequestStatus.ACCEPTED))
.isPresent()) {
throw new IllegalStateException("Contact request already exists between these users");
}
// Проверяем, что пользователь не отправляет запрос самому себе
if (contactRequest.getFromUserId().equals(contactRequest.getToUserId())) {
throw new IllegalArgumentException("Cannot send contact request to yourself");
}
return contactRepository.save(contactRequest);
}
public ContactRequest updateContactRequest(UUID id, ContactRequest contactRequest) {
ContactRequest existingContactRequest = getContactRequestById(id);
existingContactRequest.setStatus(contactRequest.getStatus());
return contactRepository.save(existingContactRequest);
}
public void deleteContactRequest(UUID id) {
contactRepository.deleteById(id);
}
}

calendar/src/main/java/com/coursework/calendar/service/EventService.java
package com.coursework.calendar.service;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;
import org.springframework.stereotype.Service;
import com.coursework.calendar.entities.event.Event;
import com.coursework.calendar.repository.EventRepository;
import com.coursework.calendar.repository.InvitationRepository;
@Service
public class EventService {
private final EventRepository eventRepository;
private final InvitationRepository invitationRepository;
public EventService(EventRepository eventRepository, InvitationRepository invitationRepository) {
this.eventRepository = eventRepository;
this.invitationRepository = invitationRepository;
}
public List<Event> getAllEvents() {
return eventRepository.findAll();
}
public Event getEventById(UUID id) {
return eventRepository.findById(id)
.orElseThrow(() -> new RuntimeException("Event not found"));
}
public List<Event> getEventsByUserId(UUID userId) {
return eventRepository.findByOwnerId(userId);
}
public List<Event> getInvitedEventsByUserId(UUID userId) {
List<UUID> eventIds = invitationRepository.findByUserId(userId).stream()
.map(invitation -> invitation.getEventId())
.collect(Collectors.toList());
if (eventIds.isEmpty()) {
return List.of();
}
return eventRepository.findAllById(eventIds);
}
public Event createEvent(Event event) {
return eventRepository.save(event);
}
public Event updateEvent(UUID id, Event event) {
Event existingEvent = getEventById(id);
existingEvent.setTitle(event.getTitle());
existingEvent.setDescription(event.getDescription());
existingEvent.setStartTime(event.getStartTime());
existingEvent.setEndTime(event.getEndTime());
existingEvent.setStatus(event.getStatus());
return eventRepository.save(existingEvent);
}
public void deleteEvent(UUID id) {
eventRepository.deleteById(id);
}
}

calendar/src/main/java/com/coursework/calendar/service/InvitationService.java
package com.coursework.calendar.service;
import java.util.List;
import java.util.UUID;
import org.springframework.stereotype.Service;
import com.coursework.calendar.entities.invitation.Invitation;
import com.coursework.calendar.repository.InvitationRepository;
@Service
public class InvitationService {
private final InvitationRepository invitationRepository;
public InvitationService(InvitationRepository invitationRepository) {
this.invitationRepository = invitationRepository;
}
public List<Invitation> getAllInvitations() {
return invitationRepository.findAll();
}
public Invitation getInvitationById(UUID id) {
return invitationRepository.findById(id)
.orElseThrow(() -> new RuntimeException("Invitation not found"));
}
public List<Invitation> getInvitationsByUserId(UUID userId) {
return invitationRepository.findByUserId(userId);
}
public Invitation createInvitation(Invitation invitation) {
return invitationRepository.save(invitation);
}
public Invitation updateInvitation(UUID id, Invitation invitation) {
Invitation existingInvitation = getInvitationById(id);
existingInvitation.setStatus(invitation.getStatus());
return invitationRepository.save(existingInvitation);
}
public void deleteInvitation(UUID id) {
if (!invitationRepository.existsById(id)) {
throw new RuntimeException("Invitation not found");
}
invitationRepository.deleteById(id);
}
}

calendar/src/main/java/com/coursework/calendar/service/JwtService.java
package com.coursework.calendar.service;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.function.Function;
import javax.crypto.SecretKey;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import com.coursework.calendar.entities.user.User;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
@Service
public class JwtService {
@Value("${jwt.secret:your-256-bit-secret-key-for-jwt-token-generation-minimum-32-characters}")
private String secret;
@Value("${jwt.access-token-expiration:900000}") // 15 минут по умолчанию
private long accessTokenExpiration;
@Value("${jwt.refresh-token-expiration:604800000}") // 7 дней по умолчанию
private long refreshTokenExpiration;
private SecretKey getSigningKey() {
byte[] keyBytes = secret.getBytes();
// JWT требует минимум 256 бит (32 байта) для HMAC-SHA
if (keyBytes.length < 32) {
byte[] secureKey = new byte[32];
if (keyBytes.length > 0) {
for (int i = 0; i < 32; i++) {
secureKey[i] = keyBytes[i % keyBytes.length];
}
} else {
String defaultSecret = "your-256-bit-secret-key-for-jwt-token-generation-minimum-32-characters";
secureKey = defaultSecret.getBytes();
}
return Keys.hmacShaKeyFor(secureKey);
}
return Keys.hmacShaKeyFor(keyBytes);
}
public String extractUsername(String token) {
return extractClaim(token, Claims::getSubject);
}
public UUID extractUserId(String token) {
String userIdStr = extractClaim(token, claims -> claims.get("userId", String.class));
return userIdStr != null ? UUID.fromString(userIdStr) : null;
}
public Date extractExpiration(String token) {
return extractClaim(token, Claims::getExpiration);
}
public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
final Claims claims = extractAllClaims(token);
return claimsResolver.apply(claims);
}
private Claims extractAllClaims(String token) {
return Jwts.parser()
.verifyWith(getSigningKey())
.build()
.parseSignedClaims(token)
.getPayload();
}
private Boolean isTokenExpired(String token) {
return extractExpiration(token).before(new Date());
}
public String generateAccessToken(User user) {
Map<String, Object> claims = new HashMap<>();
claims.put("userId", user.getId().toString());
claims.put("email", user.getEmail());
claims.put("role", user.getRole().name());
return createToken(claims, user.getEmail(), accessTokenExpiration);
}
public String generateRefreshToken(User user) {
Map<String, Object> claims = new HashMap<>();
claims.put("userId", user.getId().toString());
claims.put("type", "refresh");
return createToken(claims, user.getEmail(), refreshTokenExpiration);
}
private String createToken(Map<String, Object> claims, String subject, long expiration) {
return Jwts.builder()
.claims(claims)
.subject(subject)
.issuedAt(new Date(System.currentTimeMillis()))
.expiration(new Date(System.currentTimeMillis() + expiration))
.signWith(getSigningKey())
.compact();
}
public Boolean validateToken(String token, String username) {
final String extractedUsername = extractUsername(token);
return (extractedUsername.equals(username) && !isTokenExpired(token));
}
public Boolean validateRefreshToken(String token) {
try {
Claims claims = extractAllClaims(token);
return "refresh".equals(claims.get("type")) && !isTokenExpired(token);
} catch (Exception e) {
return false;
}
}
}

calendar/src/main/java/com/coursework/calendar/service/UserDetailsServiceImpl.java
package com.coursework.calendar.service;
import java.util.Collections;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import com.coursework.calendar.entities.user.User;
import com.coursework.calendar.repository.UserRepository;
@Service
public class UserDetailsServiceImpl implements UserDetailsService {
private final UserRepository userRepository;
public UserDetailsServiceImpl(UserRepository userRepository) {
this.userRepository = userRepository;
}
@Override
@Transactional(readOnly = true)
public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
User user = userRepository.findByEmail(email)
.orElseThrow(() -> new UsernameNotFoundException("User not found: " + email));
return org.springframework.security.core.userdetails.User.builder()
.username(user.getEmail())
.password(user.getPasswordHash())
.authorities(Collections.singletonList(() -> "ROLE_" + user.getRole().name()))
.build();
}
}

calendar/src/main/java/com/coursework/calendar/service/UserService.java
package com.coursework.calendar.service;
import java.util.List;
import java.util.UUID;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import com.coursework.calendar.entities.user.User;
import com.coursework.calendar.repository.UserRepository;
@Service
public class UserService {
private final UserRepository userRepository;
private final PasswordEncoder passwordEncoder;
public UserService(UserRepository userRepository, PasswordEncoder passwordEncoder) {
this.userRepository = userRepository;
this.passwordEncoder = passwordEncoder;
}
@Transactional(readOnly = true)
public List<User> getAllUsers() {
return userRepository.findAll();
}
@Transactional(readOnly = true)
public User getUserById(UUID id) {
return userRepository.findById(id)
.orElseThrow(() -> new RuntimeException("User not found"));
}
@Transactional(readOnly = true)
public User getUserByEmail(String email) {
return userRepository.findByEmail(email)
.orElseThrow(() -> new RuntimeException("User not found"));
}
@Transactional
public User createUser(User user) {
if (userRepository.existsByEmail(user.getEmail())) {
throw new RuntimeException("User already exists");
}
String hashedPassword = passwordEncoder.encode(user.getPasswordHash());
user.setPasswordHash(hashedPassword);
return userRepository.save(user);
}
@Transactional
public User updateUser(UUID id, User userUpdate) {
User existingUser = getUserById(id);
existingUser.setEmail(userUpdate.getEmail() != null && !userUpdate.getEmail().isEmpty() ? userUpdate.getEmail()
: existingUser.getEmail());
existingUser.setUsername(
userUpdate.getUsername() != null && !userUpdate.getUsername().isEmpty() ? userUpdate.getUsername()
: existingUser.getUsername());
existingUser.setRole(
userUpdate.getRole() != null ? userUpdate.getRole() : existingUser.getRole());
if (userUpdate.getPasswordHash() != null && !userUpdate.getPasswordHash().isEmpty()) {
String hashedPassword = passwordEncoder.encode(userUpdate.getPasswordHash());
existingUser.setPasswordHash(hashedPassword);
}
return userRepository.save(existingUser);
}
@Transactional
public void deleteUser(UUID id) {
userRepository.deleteById(id);
}
@Transactional(readOnly = true)
public org.springframework.data.domain.Page<User> searchUsers(String query, UUID excludeUserId,
org.springframework.data.domain.Pageable pageable) {
return userRepository.searchUsers(query, excludeUserId, pageable);
}
}

calendar/src/main/resources/application-dev.yaml
spring:
datasource:
url: jdbc:h2:mem:calendardb
driver-class-name: org.h2.Driver
username: sa
password:
h2:
console:
enabled: true
path: /h2-console
jpa:
database-platform: org.hibernate.dialect.H2Dialect
hibernate:
ddl-auto: none
show-sql: true
properties:
hibernate:
format_sql: true
liquibase:
change-log: classpath:db/changelog/db.changelog-master.xml
enabled: true
logging:
level:
org.hibernate.SQL: DEBUG
org.hibernate.type.descriptor.sql.BasicBinder: TRACE
org.springframework.web: DEBUG

calendar/src/main/resources/application-nopass.yaml
spring:
datasource:
url: jdbc:postgresql://localhost:5432/calendardb
driver-class-name: org.postgresql.Driver
username: postgres
password: postgres
jpa:
database-platform: org.hibernate.dialect.PostgreSQLDialect
hibernate:
ddl-auto: none
show-sql: true
properties:
hibernate:
format_sql: true
liquibase:
change-log: classpath:db/changelog/db.changelog-master.xml
enabled: true
security:
user:
name: user
password:
roles: USER
logging:
level:
org.hibernate.SQL: DEBUG
org.hibernate.type.descriptor.sql.BasicBinder: TRACE
org.springframework.web: DEBUG

calendar/src/main/resources/application-prod.yaml
spring:
datasource:
url: jdbc:postgresql://localhost:5432/calendardb
driver-class-name: org.postgresql.Driver
username: postgres
password: postgres
jpa:
database-platform: org.hibernate.dialect.PostgreSQLDialect
hibernate:
ddl-auto: none
show-sql: false
properties:
hibernate:
format_sql: false
liquibase:
change-log: classpath:db/changelog/db.changelog-master.xml
enabled: true
logging:
level:
org.springframework.web: INFO
org.hibernate: WARN

calendar/src/main/resources/application.yaml
spring:
application:
name: calendar
profiles:
active: ${SPRING_PROFILES_ACTIVE:dev}
server:
port: 8080
springdoc:
api-docs:
path: /v3/api-docs
swagger-ui:
path: /swagger-ui.html
enabled: true
jwt:
secret: ${JWT_SECRET:your-256-bit-secret-key-for-jwt-token-generation-minimum-32-characters}
access-token-expiration: ${JWT_ACCESS_EXPIRATION:900000}
refresh-token-expiration: ${JWT_REFRESH_EXPIRATION:604800000}

calendar/src/main/resources/db/changelog/changes/001-initial-schema.xml
<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.24.xsd">
<changeSet id="001-create-users-table" author="coursework">
<createTable tableName="users">
<column name="id" type="UUID">
<constraints primaryKey="true" nullable="false" />
</column>
<column name="username" type="VARCHAR(255)">
<constraints nullable="false" unique="false" />
</column>
<column name="email" type="VARCHAR(255)">
<constraints nullable="false" unique="true" />
</column>
<column name="password_hash" type="VARCHAR(255)">
<constraints nullable="false" />
</column>
<column name="role" type="VARCHAR(50)">
<constraints nullable="false" />
</column>
<column name="created_at" type="TIMESTAMP">
<constraints nullable="false" />
</column>
</createTable>
<createIndex indexName="idx_users_username" tableName="users">
<column name="username" />
</createIndex>
</changeSet>
<changeSet id="002-create-events-table" author="coursework">
<createTable tableName="events">
<column name="id" type="UUID">
<constraints primaryKey="true" nullable="false" />
</column>
<column name="title" type="VARCHAR(255)">
<constraints nullable="false" />
</column>
<column name="description" type="TEXT">
<constraints nullable="true" />
</column>
<column name="start_time" type="TIMESTAMP">
<constraints nullable="false" />
</column>
<column name="end_time" type="TIMESTAMP">
<constraints nullable="false" />
</column>
<column name="owner_id" type="UUID">
<constraints nullable="false" />
</column>
<column name="created_at" type="TIMESTAMP">
<constraints nullable="false" />
</column>
<column name="status" type="VARCHAR(50)">
<constraints nullable="false" />
</column>
</createTable>
<addForeignKeyConstraint
baseTableName="events"
baseColumnNames="owner_id"
constraintName="fk_events_owner"
referencedTableName="users"
referencedColumnNames="id"
onDelete="CASCADE" />
<createIndex indexName="idx_events_owner_id" tableName="events">
<column name="owner_id" />
</createIndex>
<createIndex indexName="idx_events_start_time" tableName="events">
<column name="start_time" />
</createIndex>
</changeSet>
<changeSet id="003-create-invitations-table" author="coursework">
<createTable tableName="invitations">
<column name="id" type="UUID">
<constraints primaryKey="true" nullable="false" />
</column>
<column name="event_id" type="UUID">
<constraints nullable="false" />
</column>
<column name="user_id" type="UUID">
<constraints nullable="false" />
</column>
<column name="created_at" type="TIMESTAMP">
<constraints nullable="false" />
</column>
<column name="status" type="VARCHAR(50)">
<constraints nullable="false" />
</column>
</createTable>
<addForeignKeyConstraint
baseTableName="invitations"
baseColumnNames="event_id"
constraintName="fk_invitations_event"
referencedTableName="events"
referencedColumnNames="id"
onDelete="CASCADE" />
<addForeignKeyConstraint
baseTableName="invitations"
baseColumnNames="user_id"
constraintName="fk_invitations_user"
referencedTableName="users"
referencedColumnNames="id"
onDelete="CASCADE" />
<createIndex indexName="idx_invitations_event_id" tableName="invitations">
<column name="event_id" />
</createIndex>
<createIndex indexName="idx_invitations_user_id" tableName="invitations">
<column name="user_id" />
</createIndex>
<createIndex indexName="idx_invitations_event_user" tableName="invitations">
<column name="event_id" />
<column name="user_id" />
</createIndex>
</changeSet>
<changeSet id="004-create-contact-requests-table" author="coursework">
<createTable tableName="contact_requests">
<column name="id" type="UUID">
<constraints primaryKey="true" nullable="false" />
</column>
<column name="created_at" type="TIMESTAMP">
<constraints nullable="false" />
</column>
<column name="responded_at" type="TIMESTAMP">
<constraints nullable="true" />
</column>
<column name="from_user_id" type="UUID">
<constraints nullable="false" />
</column>
<column name="to_user_id" type="UUID">
<constraints nullable="false" />
</column>
<column name="status" type="VARCHAR(50)">
<constraints nullable="false" />
</column>
</createTable>
<addForeignKeyConstraint
baseTableName="contact_requests"
baseColumnNames="from_user_id"
constraintName="fk_contact_requests_from_user"
referencedTableName="users"
referencedColumnNames="id"
onDelete="CASCADE" />
<addForeignKeyConstraint
baseTableName="contact_requests"
baseColumnNames="to_user_id"
constraintName="fk_contact_requests_to_user"
referencedTableName="users"
referencedColumnNames="id"
onDelete="CASCADE" />
<createIndex indexName="idx_contact_requests_from_user" tableName="contact_requests">
<column name="from_user_id" />
</createIndex>
<createIndex indexName="idx_contact_requests_to_user" tableName="contact_requests">
<column name="to_user_id" />
</createIndex>
<createIndex indexName="idx_contact_requests_from_to" tableName="contact_requests">
<column name="from_user_id" />
<column name="to_user_id" />
</createIndex>
</changeSet>
</databaseChangeLog>

calendar/src/main/resources/db/changelog/changes/002-default-admin.xml
<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.24.xsd">
<!-- Создание дефолтного администратора для профиля nopass -->
<!-- Email: admin@system.local, Password: admin -->
<!-- BCrypt hash для пароля "admin" (10 rounds):
$2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy -->
<changeSet id="002-create-default-admin" author="coursework">
<preConditions onFail="MARK_RAN">
<not>
<sqlCheck expectedResult="1"> SELECT COUNT(*) FROM users WHERE email =
'admin@system.local' </sqlCheck>
</not>
</preConditions>
<insert tableName="users">
<column name="id" valueComputed="gen_random_uuid()" />
<column name="username" value="System Admin" />
<column name="email" value="admin@system.local" />
<column name="password_hash"
value="$2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy" />
<column name="role" value="ADMIN" />
<column name="created_at" valueComputed="CURRENT_TIMESTAMP" />
</insert>
</changeSet>
</databaseChangeLog>

calendar/src/main/resources/db/changelog/db.changelog-master.xml
<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.24.xsd">
<include file="db/changelog/changes/001-initial-schema.xml"/>
<include file="db/changelog/changes/002-default-admin.xml"/>
</databaseChangeLog>

calendar/src/test/java/com/coursework/calendar/CalendarApplicationTests.java
package com.coursework.calendar;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
@SpringBootTest
class CalendarApplicationTests {
@Test
void contextLoads() {
}
}

calendar/src/test/java/com/coursework/calendar/service/ContactServiceTest.java
package com.coursework.calendar.service;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import com.coursework.calendar.entities.contact.ContactRequest;
import com.coursework.calendar.entities.contact.ContactRequestStatus;
import com.coursework.calendar.repository.ContactRepository;
@ExtendWith(MockitoExtension.class)
class ContactServiceTest {
@Mock
private ContactRepository contactRepository;
@InjectMocks
private ContactService contactService;
private ContactRequest testContactRequest;
private UUID testContactRequestId;
private UUID testFromUserId;
private UUID testToUserId;
@BeforeEach
void setUp() {
testContactRequestId = UUID.randomUUID();
testFromUserId = UUID.randomUUID();
testToUserId = UUID.randomUUID();
testContactRequest = new ContactRequest(testContactRequestId, LocalDateTime.now(), null,
testFromUserId, testToUserId, ContactRequestStatus.PENDING);
}
@Test
void getAllContactRequests_ShouldReturnListOfContactRequests() {
// Arrange
ContactRequest request1 = new ContactRequest(UUID.randomUUID(), LocalDateTime.now(), null,
UUID.randomUUID(), UUID.randomUUID(), ContactRequestStatus.PENDING);
ContactRequest request2 = new ContactRequest(UUID.randomUUID(), LocalDateTime.now(), LocalDateTime.now(),
UUID.randomUUID(), UUID.randomUUID(), ContactRequestStatus.ACCEPTED);
List<ContactRequest> expectedRequests = Arrays.asList(request1, request2);
when(contactRepository.findAll()).thenReturn(expectedRequests);
// Act
List<ContactRequest> result = contactService.getAllContactRequests();
// Assert
assertNotNull(result);
assertEquals(2, result.size());
assertEquals(expectedRequests, result);
verify(contactRepository, times(1)).findAll();
}
@Test
void getContactRequestById_WhenContactRequestExists_ShouldReturnContactRequest() {
// Arrange
when(contactRepository.findById(testContactRequestId)).thenReturn(Optional.of(testContactRequest));
// Act
ContactRequest result = contactService.getContactRequestById(testContactRequestId);
// Assert
assertNotNull(result);
assertEquals(testContactRequest.getId(), result.getId());
assertEquals(testContactRequest.getFromUserId(), result.getFromUserId());
assertEquals(testContactRequest.getToUserId(), result.getToUserId());
assertEquals(testContactRequest.getStatus(), result.getStatus());
verify(contactRepository, times(1)).findById(testContactRequestId);
}
@Test
void getContactRequestById_WhenContactRequestNotExists_ShouldThrowRuntimeException() {
// Arrange
UUID nonExistentId = UUID.randomUUID();
when(contactRepository.findById(nonExistentId)).thenReturn(Optional.empty());
// Act & Assert
RuntimeException exception = assertThrows(RuntimeException.class, () -> {
contactService.getContactRequestById(nonExistentId);
});
assertEquals("Contact request not found", exception.getMessage());
verify(contactRepository, times(1)).findById(nonExistentId);
}
@Test
void getContactRequestsByUserId_ShouldReturnCombinedList() {
// Arrange
UUID userId = UUID.randomUUID();
ContactRequest fromRequest1 = new ContactRequest(UUID.randomUUID(), LocalDateTime.now(), null,
userId, UUID.randomUUID(), ContactRequestStatus.PENDING);
ContactRequest fromRequest2 = new ContactRequest(UUID.randomUUID(), LocalDateTime.now(), null,
userId, UUID.randomUUID(), ContactRequestStatus.PENDING);
ContactRequest toRequest1 = new ContactRequest(UUID.randomUUID(), LocalDateTime.now(), null,
UUID.randomUUID(), userId, ContactRequestStatus.ACCEPTED);
ContactRequest toRequest2 = new ContactRequest(UUID.randomUUID(), LocalDateTime.now(), LocalDateTime.now(),
UUID.randomUUID(), userId, ContactRequestStatus.REJECTED);
List<ContactRequest> fromRequests = Arrays.asList(fromRequest1, fromRequest2);
List<ContactRequest> toRequests = Arrays.asList(toRequest1, toRequest2);
when(contactRepository.findByFromUserId(userId)).thenReturn(fromRequests);
when(contactRepository.findByToUserId(userId)).thenReturn(toRequests);
// Act
List<ContactRequest> result = contactService.getContactRequestsByUserId(userId);
// Assert
assertNotNull(result);
assertEquals(4, result.size());
assertTrue(result.containsAll(fromRequests));
assertTrue(result.containsAll(toRequests));
verify(contactRepository, times(1)).findByFromUserId(userId);
verify(contactRepository, times(1)).findByToUserId(userId);
}
@Test
void getContactRequestsByUserId_WhenNoRequests_ShouldReturnEmptyList() {
// Arrange
UUID userId = UUID.randomUUID();
when(contactRepository.findByFromUserId(userId)).thenReturn(Arrays.asList());
when(contactRepository.findByToUserId(userId)).thenReturn(Arrays.asList());
// Act
List<ContactRequest> result = contactService.getContactRequestsByUserId(userId);
// Assert
assertNotNull(result);
assertTrue(result.isEmpty());
verify(contactRepository, times(1)).findByFromUserId(userId);
verify(contactRepository, times(1)).findByToUserId(userId);
}
@Test
void createContactRequest_ShouldSaveAndReturnContactRequest() {
// Arrange
ContactRequest newRequest = new ContactRequest(null, LocalDateTime.now(), null,
testFromUserId, testToUserId, ContactRequestStatus.PENDING);
ContactRequest savedRequest = new ContactRequest(UUID.randomUUID(), LocalDateTime.now(), null,
testFromUserId, testToUserId, ContactRequestStatus.PENDING);
when(contactRepository.save(any(ContactRequest.class))).thenReturn(savedRequest);
// Act
ContactRequest result = contactService.createContactRequest(newRequest);
// Assert
assertNotNull(result);
assertEquals(savedRequest.getId(), result.getId());
assertEquals(savedRequest.getFromUserId(), result.getFromUserId());
assertEquals(savedRequest.getToUserId(), result.getToUserId());
verify(contactRepository, times(1)).save(any(ContactRequest.class));
}
@Test
void updateContactRequest_WhenContactRequestExists_ShouldUpdateAndReturnContactRequest() {
// Arrange
ContactRequest updateData = new ContactRequest(null, LocalDateTime.now(), LocalDateTime.now(),
testFromUserId, testToUserId, ContactRequestStatus.ACCEPTED);
ContactRequest updatedRequest = new ContactRequest(testContactRequestId, testContactRequest.getCreatedAt(),
LocalDateTime.now(), testFromUserId, testToUserId, ContactRequestStatus.ACCEPTED);
when(contactRepository.findById(testContactRequestId)).thenReturn(Optional.of(testContactRequest));
when(contactRepository.save(any(ContactRequest.class))).thenReturn(updatedRequest);
// Act
ContactRequest result = contactService.updateContactRequest(testContactRequestId, updateData);
// Assert
assertNotNull(result);
assertEquals(ContactRequestStatus.ACCEPTED, result.getStatus());
verify(contactRepository, times(1)).findById(testContactRequestId);
verify(contactRepository, times(1)).save(any(ContactRequest.class));
}
@Test
void updateContactRequest_WhenContactRequestNotExists_ShouldThrowRuntimeException() {
// Arrange
UUID nonExistentId = UUID.randomUUID();
ContactRequest updateData = new ContactRequest(null, LocalDateTime.now(), null,
testFromUserId, testToUserId, ContactRequestStatus.REJECTED);
when(contactRepository.findById(nonExistentId)).thenReturn(Optional.empty());
// Act & Assert
RuntimeException exception = assertThrows(RuntimeException.class, () -> {
contactService.updateContactRequest(nonExistentId, updateData);
});
assertEquals("Contact request not found", exception.getMessage());
verify(contactRepository, times(1)).findById(nonExistentId);
verify(contactRepository, never()).save(any(ContactRequest.class));
}
@Test
void deleteContactRequest_ShouldCallRepositoryDelete() {
// Arrange
UUID contactRequestId = UUID.randomUUID();
doNothing().when(contactRepository).deleteById(contactRequestId);
// Act
contactService.deleteContactRequest(contactRequestId);
// Assert
verify(contactRepository, times(1)).deleteById(contactRequestId);
}
}

calendar/src/test/java/com/coursework/calendar/service/EventServiceTest.java
package com.coursework.calendar.service;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import com.coursework.calendar.entities.event.Event;
import com.coursework.calendar.entities.event.EventStatus;
import com.coursework.calendar.repository.EventRepository;
@ExtendWith(MockitoExtension.class)
class EventServiceTest {
@Mock
private EventRepository eventRepository;
@InjectMocks
private EventService eventService;
private Event testEvent;
private UUID testEventId;
private UUID testOwnerId;
@BeforeEach
void setUp() {
testEventId = UUID.randomUUID();
testOwnerId = UUID.randomUUID();
testEvent = new Event(testEventId, "Test Event", "Test Description",
LocalDateTime.now(), LocalDateTime.now().plusHours(2),
testOwnerId, LocalDateTime.now(), EventStatus.PUBLISHED);
}
@Test
void getAllEvents_ShouldReturnListOfEvents() {
// Arrange
Event event1 = new Event(UUID.randomUUID(), "Event 1", "Description 1",
LocalDateTime.now(), LocalDateTime.now().plusHours(1),
UUID.randomUUID(), LocalDateTime.now(), EventStatus.PUBLISHED);
Event event2 = new Event(UUID.randomUUID(), "Event 2", "Description 2",
LocalDateTime.now(), LocalDateTime.now().plusHours(2),
UUID.randomUUID(), LocalDateTime.now(), EventStatus.DRAFT);
List<Event> expectedEvents = Arrays.asList(event1, event2);
when(eventRepository.findAll()).thenReturn(expectedEvents);
// Act
List<Event> result = eventService.getAllEvents();
// Assert
assertNotNull(result);
assertEquals(2, result.size());
assertEquals(expectedEvents, result);
verify(eventRepository, times(1)).findAll();
}
@Test
void getEventById_WhenEventExists_ShouldReturnEvent() {
// Arrange
when(eventRepository.findById(testEventId)).thenReturn(Optional.of(testEvent));
// Act
Event result = eventService.getEventById(testEventId);
// Assert
assertNotNull(result);
assertEquals(testEvent.getId(), result.getId());
assertEquals(testEvent.getTitle(), result.getTitle());
assertEquals(testEvent.getDescription(), result.getDescription());
verify(eventRepository, times(1)).findById(testEventId);
}
@Test
void getEventById_WhenEventNotExists_ShouldThrowRuntimeException() {
// Arrange
UUID nonExistentId = UUID.randomUUID();
when(eventRepository.findById(nonExistentId)).thenReturn(Optional.empty());
// Act & Assert
RuntimeException exception = assertThrows(RuntimeException.class, () -> {
eventService.getEventById(nonExistentId);
});
assertEquals("Event not found", exception.getMessage());
verify(eventRepository, times(1)).findById(nonExistentId);
}
@Test
void getEventsByUserId_ShouldReturnListOfEvents() {
// Arrange
Event event1 = new Event(UUID.randomUUID(), "Event 1", "Description 1",
LocalDateTime.now(), LocalDateTime.now().plusHours(1),
testOwnerId, LocalDateTime.now(), EventStatus.PUBLISHED);
Event event2 = new Event(UUID.randomUUID(), "Event 2", "Description 2",
LocalDateTime.now(), LocalDateTime.now().plusHours(2),
testOwnerId, LocalDateTime.now(), EventStatus.DRAFT);
List<Event> expectedEvents = Arrays.asList(event1, event2);
when(eventRepository.findByOwnerId(testOwnerId)).thenReturn(expectedEvents);
// Act
List<Event> result = eventService.getEventsByUserId(testOwnerId);
// Assert
assertNotNull(result);
assertEquals(2, result.size());
assertEquals(expectedEvents, result);
verify(eventRepository, times(1)).findByOwnerId(testOwnerId);
}
@Test
void getEventsByUserId_WhenNoEvents_ShouldReturnEmptyList() {
// Arrange
UUID userId = UUID.randomUUID();
when(eventRepository.findByOwnerId(userId)).thenReturn(Arrays.asList());
// Act
List<Event> result = eventService.getEventsByUserId(userId);
// Assert
assertNotNull(result);
assertTrue(result.isEmpty());
verify(eventRepository, times(1)).findByOwnerId(userId);
}
@Test
void createEvent_ShouldSaveAndReturnEvent() {
// Arrange
Event newEvent = new Event(null, "New Event", "New Description",
LocalDateTime.now(), LocalDateTime.now().plusHours(1),
testOwnerId, LocalDateTime.now(), EventStatus.DRAFT);
Event savedEvent = new Event(UUID.randomUUID(), "New Event", "New Description",
newEvent.getStartTime(), newEvent.getEndTime(),
testOwnerId, LocalDateTime.now(), EventStatus.DRAFT);
when(eventRepository.save(any(Event.class))).thenReturn(savedEvent);
// Act
Event result = eventService.createEvent(newEvent);
// Assert
assertNotNull(result);
assertEquals(savedEvent.getId(), result.getId());
assertEquals(savedEvent.getTitle(), result.getTitle());
verify(eventRepository, times(1)).save(any(Event.class));
}
@Test
void updateEvent_WhenEventExists_ShouldUpdateAndReturnEvent() {
// Arrange
Event updateData = new Event(null, "Updated Event", "Updated Description",
LocalDateTime.now().plusDays(1), LocalDateTime.now().plusDays(1).plusHours(2),
testOwnerId, LocalDateTime.now(), EventStatus.CANCELLED);
Event updatedEvent = new Event(testEventId, "Updated Event", "Updated Description",
updateData.getStartTime(), updateData.getEndTime(),
testOwnerId, testEvent.getCreatedAt(), EventStatus.CANCELLED);
when(eventRepository.findById(testEventId)).thenReturn(Optional.of(testEvent));
when(eventRepository.save(any(Event.class))).thenReturn(updatedEvent);
// Act
Event result = eventService.updateEvent(testEventId, updateData);
// Assert
assertNotNull(result);
assertEquals("Updated Event", result.getTitle());
assertEquals("Updated Description", result.getDescription());
assertEquals(EventStatus.CANCELLED, result.getStatus());
assertEquals(updateData.getStartTime(), result.getStartTime());
assertEquals(updateData.getEndTime(), result.getEndTime());
verify(eventRepository, times(1)).findById(testEventId);
verify(eventRepository, times(1)).save(any(Event.class));
}
@Test
void updateEvent_WhenEventNotExists_ShouldThrowRuntimeException() {
// Arrange
UUID nonExistentId = UUID.randomUUID();
Event updateData = new Event(null, "Updated Event", "Updated Description",
LocalDateTime.now(), LocalDateTime.now().plusHours(2),
testOwnerId, LocalDateTime.now(), EventStatus.PUBLISHED);
when(eventRepository.findById(nonExistentId)).thenReturn(Optional.empty());
// Act & Assert
RuntimeException exception = assertThrows(RuntimeException.class, () -> {
eventService.updateEvent(nonExistentId, updateData);
});
assertEquals("Event not found", exception.getMessage());
verify(eventRepository, times(1)).findById(nonExistentId);
verify(eventRepository, never()).save(any(Event.class));
}
@Test
void deleteEvent_ShouldCallRepositoryDelete() {
// Arrange
UUID eventId = UUID.randomUUID();
doNothing().when(eventRepository).deleteById(eventId);
// Act
eventService.deleteEvent(eventId);
// Assert
verify(eventRepository, times(1)).deleteById(eventId);
}
}

calendar/src/test/java/com/coursework/calendar/service/InvitationServiceTest.java
package com.coursework.calendar.service;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import com.coursework.calendar.entities.invitation.Invitation;
import com.coursework.calendar.entities.invitation.InvitationStatus;
import com.coursework.calendar.repository.InvitationRepository;
@ExtendWith(MockitoExtension.class)
class InvitationServiceTest {
@Mock
private InvitationRepository invitationRepository;
@InjectMocks
private InvitationService invitationService;
private Invitation testInvitation;
private UUID testInvitationId;
private UUID testEventId;
private UUID testUserId;
@BeforeEach
void setUp() {
testInvitationId = UUID.randomUUID();
testEventId = UUID.randomUUID();
testUserId = UUID.randomUUID();
testInvitation = new Invitation(testInvitationId, testEventId, testUserId,
LocalDateTime.now(), InvitationStatus.PENDING);
}
@Test
void getAllInvitations_ShouldReturnListOfInvitations() {
// Arrange
Invitation invitation1 = new Invitation(UUID.randomUUID(), UUID.randomUUID(),
UUID.randomUUID(), LocalDateTime.now(), InvitationStatus.PENDING);
Invitation invitation2 = new Invitation(UUID.randomUUID(), UUID.randomUUID(),
UUID.randomUUID(), LocalDateTime.now(), InvitationStatus.ACCEPTED);
List<Invitation> expectedInvitations = Arrays.asList(invitation1, invitation2);
when(invitationRepository.findAll()).thenReturn(expectedInvitations);
// Act
List<Invitation> result = invitationService.getAllInvitations();
// Assert
assertNotNull(result);
assertEquals(2, result.size());
assertEquals(expectedInvitations, result);
verify(invitationRepository, times(1)).findAll();
}
@Test
void getInvitationById_WhenInvitationExists_ShouldReturnInvitation() {
// Arrange
when(invitationRepository.findById(testInvitationId)).thenReturn(Optional.of(testInvitation));
// Act
Invitation result = invitationService.getInvitationById(testInvitationId);
// Assert
assertNotNull(result);
assertEquals(testInvitation.getId(), result.getId());
assertEquals(testInvitation.getEventId(), result.getEventId());
assertEquals(testInvitation.getUserId(), result.getUserId());
assertEquals(testInvitation.getStatus(), result.getStatus());
verify(invitationRepository, times(1)).findById(testInvitationId);
}
@Test
void getInvitationById_WhenInvitationNotExists_ShouldThrowRuntimeException() {
// Arrange
UUID nonExistentId = UUID.randomUUID();
when(invitationRepository.findById(nonExistentId)).thenReturn(Optional.empty());
// Act & Assert
RuntimeException exception = assertThrows(RuntimeException.class, () -> {
invitationService.getInvitationById(nonExistentId);
});
assertEquals("Invitation not found", exception.getMessage());
verify(invitationRepository, times(1)).findById(nonExistentId);
}
@Test
void getInvitationsByUserId_ShouldReturnListOfInvitations() {
// Arrange
Invitation invitation1 = new Invitation(UUID.randomUUID(), UUID.randomUUID(),
testUserId, LocalDateTime.now(), InvitationStatus.PENDING);
Invitation invitation2 = new Invitation(UUID.randomUUID(), UUID.randomUUID(),
testUserId, LocalDateTime.now(), InvitationStatus.ACCEPTED);
List<Invitation> expectedInvitations = Arrays.asList(invitation1, invitation2);
when(invitationRepository.findByUserId(testUserId)).thenReturn(expectedInvitations);
// Act
List<Invitation> result = invitationService.getInvitationsByUserId(testUserId);
// Assert
assertNotNull(result);
assertEquals(2, result.size());
assertEquals(expectedInvitations, result);
verify(invitationRepository, times(1)).findByUserId(testUserId);
}
@Test
void getInvitationsByUserId_WhenNoInvitations_ShouldReturnEmptyList() {
// Arrange
UUID userId = UUID.randomUUID();
when(invitationRepository.findByUserId(userId)).thenReturn(Arrays.asList());
// Act
List<Invitation> result = invitationService.getInvitationsByUserId(userId);
// Assert
assertNotNull(result);
assertTrue(result.isEmpty());
verify(invitationRepository, times(1)).findByUserId(userId);
}
@Test
void createInvitation_ShouldSaveAndReturnInvitation() {
// Arrange
Invitation newInvitation = new Invitation(null, testEventId, testUserId,
LocalDateTime.now(), InvitationStatus.PENDING);
Invitation savedInvitation = new Invitation(UUID.randomUUID(), testEventId, testUserId,
LocalDateTime.now(), InvitationStatus.PENDING);
when(invitationRepository.save(any(Invitation.class))).thenReturn(savedInvitation);
// Act
Invitation result = invitationService.createInvitation(newInvitation);
// Assert
assertNotNull(result);
assertEquals(savedInvitation.getId(), result.getId());
assertEquals(savedInvitation.getEventId(), result.getEventId());
assertEquals(savedInvitation.getUserId(), result.getUserId());
verify(invitationRepository, times(1)).save(any(Invitation.class));
}
@Test
void updateInvitation_WhenInvitationExists_ShouldUpdateAndReturnInvitation() {
// Arrange
Invitation updateData = new Invitation(null, testEventId, testUserId,
LocalDateTime.now(), InvitationStatus.ACCEPTED);
Invitation updatedInvitation = new Invitation(testInvitationId, testEventId, testUserId,
testInvitation.getCreatedAt(), InvitationStatus.ACCEPTED);
when(invitationRepository.findById(testInvitationId)).thenReturn(Optional.of(testInvitation));
when(invitationRepository.save(any(Invitation.class))).thenReturn(updatedInvitation);
// Act
Invitation result = invitationService.updateInvitation(testInvitationId, updateData);
// Assert
assertNotNull(result);
assertEquals(InvitationStatus.ACCEPTED, result.getStatus());
verify(invitationRepository, times(1)).findById(testInvitationId);
verify(invitationRepository, times(1)).save(any(Invitation.class));
}
@Test
void updateInvitation_WhenInvitationNotExists_ShouldThrowRuntimeException() {
// Arrange
UUID nonExistentId = UUID.randomUUID();
Invitation updateData = new Invitation(null, testEventId, testUserId,
LocalDateTime.now(), InvitationStatus.REJECTED);
when(invitationRepository.findById(nonExistentId)).thenReturn(Optional.empty());
// Act & Assert
RuntimeException exception = assertThrows(RuntimeException.class, () -> {
invitationService.updateInvitation(nonExistentId, updateData);
});
assertEquals("Invitation not found", exception.getMessage());
verify(invitationRepository, times(1)).findById(nonExistentId);
verify(invitationRepository, never()).save(any(Invitation.class));
}
@Test
void deleteInvitation_ShouldCallRepositoryDelete() {
// Arrange
UUID invitationId = UUID.randomUUID();
doNothing().when(invitationRepository).deleteById(invitationId);
// Act
invitationService.deleteInvitation(invitationId);
// Assert
verify(invitationRepository, times(1)).deleteById(invitationId);
}
}

calendar/src/test/java/com/coursework/calendar/service/JwtServiceTest.java
package com.coursework.calendar.service;
import static org.junit.jupiter.api.Assertions.*;
import java.time.LocalDateTime;
import java.util.Date;
import java.util.UUID;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;
import com.coursework.calendar.entities.user.User;
import com.coursework.calendar.entities.user.UserRole;
@ExtendWith(MockitoExtension.class)
class JwtServiceTest {
@InjectMocks
private JwtService jwtService;
private User testUser;
private String testSecret;
@BeforeEach
void setUp() {
testSecret = "test-secret-key-for-jwt-token-generation-minimum-32-characters-long";
ReflectionTestUtils.setField(jwtService, "secret", testSecret);
ReflectionTestUtils.setField(jwtService, "accessTokenExpiration", 900000L); // 15 minutes
ReflectionTestUtils.setField(jwtService, "refreshTokenExpiration", 604800000L); // 7 days
UUID userId = UUID.randomUUID();
testUser = new User(userId, "testuser", "test@example.com", LocalDateTime.now(), "password123", UserRole.USER);
}
@Test
void generateAccessToken_ShouldReturnValidToken() {
// Act
String token = jwtService.generateAccessToken(testUser);
// Assert
assertNotNull(token);
assertFalse(token.isEmpty());
}
@Test
void generateAccessToken_ShouldContainUserInfo() {
// Act
String token = jwtService.generateAccessToken(testUser);
// Assert
String username = jwtService.extractUsername(token);
UUID userId = jwtService.extractUserId(token);
assertEquals(testUser.getEmail(), username);
assertEquals(testUser.getId(), userId);
}
@Test
void generateRefreshToken_ShouldReturnValidToken() {
// Act
String token = jwtService.generateRefreshToken(testUser);
// Assert
assertNotNull(token);
assertFalse(token.isEmpty());
}
@Test
void generateRefreshToken_ShouldBeValidRefreshToken() {
// Act
String token = jwtService.generateRefreshToken(testUser);
// Assert
assertTrue(jwtService.validateRefreshToken(token));
}
@Test
void extractUsername_ShouldReturnCorrectEmail() {
// Arrange
String token = jwtService.generateAccessToken(testUser);
// Act
String username = jwtService.extractUsername(token);
// Assert
assertEquals(testUser.getEmail(), username);
}
@Test
void extractUserId_ShouldReturnCorrectUserId() {
// Arrange
String token = jwtService.generateAccessToken(testUser);
// Act
UUID userId = jwtService.extractUserId(token);
// Assert
assertEquals(testUser.getId(), userId);
}
@Test
void extractExpiration_ShouldReturnFutureDate() {
// Arrange
String token = jwtService.generateAccessToken(testUser);
// Act
Date expiration = jwtService.extractExpiration(token);
// Assert
assertNotNull(expiration);
assertTrue(expiration.after(new Date()));
}
@Test
void validateToken_WhenTokenIsValid_ShouldReturnTrue() {
// Arrange
String token = jwtService.generateAccessToken(testUser);
// Act
Boolean isValid = jwtService.validateToken(token, testUser.getEmail());
// Assert
assertTrue(isValid);
}
@Test
void validateToken_WhenUsernameDoesNotMatch_ShouldReturnFalse() {
// Arrange
String token = jwtService.generateAccessToken(testUser);
// Act
Boolean isValid = jwtService.validateToken(token, "wrong@example.com");
// Assert
assertFalse(isValid);
}
@Test
void validateRefreshToken_WhenTokenIsValid_ShouldReturnTrue() {
// Arrange
String token = jwtService.generateRefreshToken(testUser);
// Act
Boolean isValid = jwtService.validateRefreshToken(token);
// Assert
assertTrue(isValid);
}
@Test
void validateRefreshToken_WhenTokenIsAccessToken_ShouldReturnFalse() {
// Arrange
String accessToken = jwtService.generateAccessToken(testUser);
// Act
Boolean isValid = jwtService.validateRefreshToken(accessToken);
// Assert
assertFalse(isValid);
}
@Test
void validateRefreshToken_WhenTokenIsInvalid_ShouldReturnFalse() {
// Arrange
String invalidToken = "invalid.token.here";
// Act
Boolean isValid = jwtService.validateRefreshToken(invalidToken);
// Assert
assertFalse(isValid);
}
@Test
void validateRefreshToken_WhenTokenIsNull_ShouldReturnFalse() {
// Act
Boolean isValid = jwtService.validateRefreshToken(null);
// Assert
assertFalse(isValid);
}
@Test
void generateAccessToken_WithShortSecret_ShouldStillWork() {
// Arrange
ReflectionTestUtils.setField(jwtService, "secret", "short");
User user = new User(UUID.randomUUID(), "user", "user@example.com", LocalDateTime.now(), "pass", UserRole.USER);
// Act
String token = jwtService.generateAccessToken(user);
// Assert
assertNotNull(token);
assertFalse(token.isEmpty());
}
@Test
void generateAccessToken_WithEmptySecret_ShouldUseDefault() {
// Arrange
ReflectionTestUtils.setField(jwtService, "secret", "");
User user = new User(UUID.randomUUID(), "user", "user@example.com", LocalDateTime.now(), "pass", UserRole.USER);
// Act
String token = jwtService.generateAccessToken(user);
// Assert
assertNotNull(token);
assertFalse(token.isEmpty());
}
@Test
void extractUsername_FromRefreshToken_ShouldReturnCorrectEmail() {
// Arrange
String token = jwtService.generateRefreshToken(testUser);
// Act
String username = jwtService.extractUsername(token);
// Assert
assertEquals(testUser.getEmail(), username);
}
@Test
void extractUserId_FromRefreshToken_ShouldReturnCorrectUserId() {
// Arrange
String token = jwtService.generateRefreshToken(testUser);
// Act
UUID userId = jwtService.extractUserId(token);
// Assert
assertEquals(testUser.getId(), userId);
}
}

calendar/src/test/java/com/coursework/calendar/service/UserDetailsServiceImplTest.java
package com.coursework.calendar.service;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
import java.time.LocalDateTime;
import java.util.Optional;
import java.util.UUID;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import com.coursework.calendar.entities.user.User;
import com.coursework.calendar.entities.user.UserRole;
import com.coursework.calendar.repository.UserRepository;
@ExtendWith(MockitoExtension.class)
class UserDetailsServiceImplTest {
@Mock
private UserRepository userRepository;
@InjectMocks
private UserDetailsServiceImpl userDetailsService;
private User testUser;
private String testEmail;
@BeforeEach
void setUp() {
testEmail = "test@example.com";
UUID userId = UUID.randomUUID();
testUser = new User(userId, "testuser", testEmail, LocalDateTime.now(), "hashedPassword123", UserRole.USER);
}
@Test
void loadUserByUsername_WhenUserExists_ShouldReturnUserDetails() {
// Arrange
when(userRepository.findByEmail(testEmail)).thenReturn(Optional.of(testUser));
// Act
UserDetails userDetails = userDetailsService.loadUserByUsername(testEmail);
// Assert
assertNotNull(userDetails);
assertEquals(testUser.getEmail(), userDetails.getUsername());
assertEquals(testUser.getPasswordHash(), userDetails.getPassword());
assertTrue(userDetails.getAuthorities().stream()
.anyMatch(a -> a.getAuthority().equals("ROLE_USER")));
verify(userRepository, times(1)).findByEmail(testEmail);
}
@Test
void loadUserByUsername_WhenUserIsAdmin_ShouldReturnAdminRole() {
// Arrange
User adminUser = new User(UUID.randomUUID(), "admin", "admin@example.com",
LocalDateTime.now(), "hashedPassword123", UserRole.ADMIN);
when(userRepository.findByEmail("admin@example.com")).thenReturn(Optional.of(adminUser));
// Act
UserDetails userDetails = userDetailsService.loadUserByUsername("admin@example.com");
// Assert
assertNotNull(userDetails);
assertTrue(userDetails.getAuthorities().stream()
.anyMatch(a -> a.getAuthority().equals("ROLE_ADMIN")));
verify(userRepository, times(1)).findByEmail("admin@example.com");
}
@Test
void loadUserByUsername_WhenUserNotExists_ShouldThrowUsernameNotFoundException() {
// Arrange
String nonExistentEmail = "nonexistent@example.com";
when(userRepository.findByEmail(nonExistentEmail)).thenReturn(Optional.empty());
// Act & Assert
UsernameNotFoundException exception = assertThrows(UsernameNotFoundException.class, () -> {
userDetailsService.loadUserByUsername(nonExistentEmail);
});
assertEquals("User not found: " + nonExistentEmail, exception.getMessage());
verify(userRepository, times(1)).findByEmail(nonExistentEmail);
}
@Test
void loadUserByUsername_ShouldSetCorrectPassword() {
// Arrange
String passwordHash = "bcrypt_hashed_password_123";
User userWithPassword = new User(UUID.randomUUID(), "user", testEmail,
LocalDateTime.now(), passwordHash, UserRole.USER);
when(userRepository.findByEmail(testEmail)).thenReturn(Optional.of(userWithPassword));
// Act
UserDetails userDetails = userDetailsService.loadUserByUsername(testEmail);
// Assert
assertEquals(passwordHash, userDetails.getPassword());
verify(userRepository, times(1)).findByEmail(testEmail);
}
@Test
void loadUserByUsername_ShouldSetCorrectUsername() {
// Arrange
when(userRepository.findByEmail(testEmail)).thenReturn(Optional.of(testUser));
// Act
UserDetails userDetails = userDetailsService.loadUserByUsername(testEmail);
// Assert
assertEquals(testUser.getEmail(), userDetails.getUsername());
verify(userRepository, times(1)).findByEmail(testEmail);
}
@Test
void loadUserByUsername_WithDifferentUserRoles_ShouldSetCorrectRole() {
// Arrange
User userRole = new User(UUID.randomUUID(), "user", "user@example.com",
LocalDateTime.now(), "pass", UserRole.USER);
User adminRole = new User(UUID.randomUUID(), "admin", "admin@example.com",
LocalDateTime.now(), "pass", UserRole.ADMIN);
when(userRepository.findByEmail("user@example.com")).thenReturn(Optional.of(userRole));
when(userRepository.findByEmail("admin@example.com")).thenReturn(Optional.of(adminRole));
// Act
UserDetails userDetails1 = userDetailsService.loadUserByUsername("user@example.com");
UserDetails userDetails2 = userDetailsService.loadUserByUsername("admin@example.com");
// Assert
assertTrue(userDetails1.getAuthorities().stream()
.anyMatch(a -> a.getAuthority().equals("ROLE_USER")));
assertTrue(userDetails2.getAuthorities().stream()
.anyMatch(a -> a.getAuthority().equals("ROLE_ADMIN")));
}
}

calendar/src/test/java/com/coursework/calendar/service/UserServiceTest.java
package com.coursework.calendar.service;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.crypto.password.PasswordEncoder;
import com.coursework.calendar.entities.user.User;
import com.coursework.calendar.entities.user.UserRole;
import com.coursework.calendar.repository.UserRepository;
@ExtendWith(MockitoExtension.class)
class UserServiceTest {
@Mock
private UserRepository userRepository;
@Mock
private PasswordEncoder passwordEncoder;
@InjectMocks
private UserService userService;
private User testUser;
private UUID testUserId;
@BeforeEach
void setUp() {
testUserId = UUID.randomUUID();
testUser = new User(testUserId, "testuser", "test@example.com", LocalDateTime.now(), "password123",
UserRole.USER);
}
@Test
void getAllUsers_ShouldReturnListOfUsers() {
// Arrange
User user1 = new User(UUID.randomUUID(), "user1", "user1@example.com", LocalDateTime.now(), "pass1",
UserRole.USER);
User user2 = new User(UUID.randomUUID(), "user2", "user2@example.com", LocalDateTime.now(), "pass2",
UserRole.ADMIN);
List<User> expectedUsers = Arrays.asList(user1, user2);
when(userRepository.findAll()).thenReturn(expectedUsers);
// Act
List<User> result = userService.getAllUsers();
// Assert
assertNotNull(result);
assertEquals(2, result.size());
assertEquals(expectedUsers, result);
verify(userRepository, times(1)).findAll();
}
@Test
void getUserById_WhenUserExists_ShouldReturnUser() {
// Arrange
when(userRepository.findById(testUserId)).thenReturn(Optional.of(testUser));
// Act
User result = userService.getUserById(testUserId);
// Assert
assertNotNull(result);
assertEquals(testUser.getId(), result.getId());
assertEquals(testUser.getEmail(), result.getEmail());
assertEquals(testUser.getUsername(), result.getUsername());
verify(userRepository, times(1)).findById(testUserId);
}
@Test
void getUserById_WhenUserNotExists_ShouldThrowRuntimeException() {
// Arrange
UUID nonExistentId = UUID.randomUUID();
when(userRepository.findById(nonExistentId)).thenReturn(Optional.empty());
// Act & Assert
RuntimeException exception = assertThrows(RuntimeException.class, () -> {
userService.getUserById(nonExistentId);
});
assertEquals("User not found", exception.getMessage());
verify(userRepository, times(1)).findById(nonExistentId);
}
@Test
void getUserByEmail_WhenUserExists_ShouldReturnUser() {
// Arrange
String email = "test@example.com";
when(userRepository.findByEmail(email)).thenReturn(Optional.of(testUser));
// Act
User result = userService.getUserByEmail(email);
// Assert
assertNotNull(result);
assertEquals(testUser.getEmail(), result.getEmail());
verify(userRepository, times(1)).findByEmail(email);
}
@Test
void getUserByEmail_WhenUserNotExists_ShouldThrowRuntimeException() {
// Arrange
String nonExistentEmail = "nonexistent@example.com";
when(userRepository.findByEmail(nonExistentEmail)).thenReturn(Optional.empty());
// Act & Assert
RuntimeException exception = assertThrows(RuntimeException.class, () -> {
userService.getUserByEmail(nonExistentEmail);
});
assertEquals("User not found", exception.getMessage());
verify(userRepository, times(1)).findByEmail(nonExistentEmail);
}
@Test
void createUser_WhenUserDoesNotExist_ShouldCreateAndReturnUser() {
// Arrange
String originalPassword = "password123";
User newUser = new User(null, "newuser", "newuser@example.com", LocalDateTime.now(), originalPassword,
UserRole.USER);
String hashedPassword = "hashed_password_123";
User savedUser = new User(UUID.randomUUID(), "newuser", "newuser@example.com", LocalDateTime.now(),
hashedPassword, UserRole.USER);
when(userRepository.existsByEmail(newUser.getEmail())).thenReturn(false);
when(passwordEncoder.encode(originalPassword)).thenReturn(hashedPassword);
when(userRepository.save(any(User.class))).thenReturn(savedUser);
// Act
User result = userService.createUser(newUser);
// Assert
assertNotNull(result);
assertEquals(hashedPassword, result.getPasswordHash());
verify(userRepository, times(1)).existsByEmail(newUser.getEmail());
verify(passwordEncoder, times(1)).encode(originalPassword);
verify(userRepository, times(1)).save(any(User.class));
}
@Test
void createUser_WhenUserAlreadyExists_ShouldThrowRuntimeException() {
// Arrange
User existingUser = new User(null, "existing", "existing@example.com", LocalDateTime.now(), "password123",
UserRole.USER);
when(userRepository.existsByEmail(existingUser.getEmail())).thenReturn(true);
// Act & Assert
RuntimeException exception = assertThrows(RuntimeException.class, () -> {
userService.createUser(existingUser);
});
assertEquals("User already exists", exception.getMessage());
verify(userRepository, times(1)).existsByEmail(existingUser.getEmail());
verify(passwordEncoder, never()).encode(anyString());
verify(userRepository, never()).save(any(User.class));
}
@Test
void updateUser_WhenUserExists_ShouldUpdateAndReturnUser() {
// Arrange
User updateData = new User(null, "updateduser", "updated@example.com", LocalDateTime.now(), "newpassword",
UserRole.ADMIN);
String hashedPassword = "hashed_new_password";
User updatedUser = new User(testUserId, "updateduser", "updated@example.com", LocalDateTime.now(),
hashedPassword, UserRole.ADMIN);
when(userRepository.findById(testUserId)).thenReturn(Optional.of(testUser));
when(passwordEncoder.encode(updateData.getPasswordHash())).thenReturn(hashedPassword);
when(userRepository.save(any(User.class))).thenReturn(updatedUser);
// Act
User result = userService.updateUser(testUserId, updateData);
// Assert
assertNotNull(result);
assertEquals("updateduser", result.getUsername());
assertEquals("updated@example.com", result.getEmail());
assertEquals(UserRole.ADMIN, result.getRole());
assertEquals(hashedPassword, result.getPasswordHash());
verify(userRepository, times(1)).findById(testUserId);
verify(passwordEncoder, times(1)).encode(updateData.getPasswordHash());
verify(userRepository, times(1)).save(any(User.class));
}
@Test
void updateUser_WhenUserNotExists_ShouldThrowRuntimeException() {
// Arrange
UUID nonExistentId = UUID.randomUUID();
User updateData = new User(null, "updateduser", "updated@example.com", LocalDateTime.now(), "newpassword",
UserRole.ADMIN);
when(userRepository.findById(nonExistentId)).thenReturn(Optional.empty());
// Act & Assert
RuntimeException exception = assertThrows(RuntimeException.class, () -> {
userService.updateUser(nonExistentId, updateData);
});
assertEquals("User not found", exception.getMessage());
verify(userRepository, times(1)).findById(nonExistentId);
verify(userRepository, never()).save(any(User.class));
}
@Test
void updateUser_WhenPasswordIsNull_ShouldNotUpdatePassword() {
// Arrange
User updateData = new User(null, "updateduser", "updated@example.com", LocalDateTime.now(), null,
UserRole.ADMIN);
User updatedUser = new User(testUserId, "updateduser", "updated@example.com", LocalDateTime.now(),
testUser.getPasswordHash(), UserRole.ADMIN);
when(userRepository.findById(testUserId)).thenReturn(Optional.of(testUser));
when(userRepository.save(any(User.class))).thenReturn(updatedUser);
// Act
User result = userService.updateUser(testUserId, updateData);
// Assert
assertNotNull(result);
assertEquals("updateduser", result.getUsername());
assertEquals(testUser.getPasswordHash(), result.getPasswordHash());
verify(userRepository, times(1)).findById(testUserId);
verify(passwordEncoder, never()).encode(anyString());
verify(userRepository, times(1)).save(any(User.class));
}
@Test
void updateUser_WhenPasswordIsEmpty_ShouldNotUpdatePassword() {
// Arrange
User updateData = new User(null, "updateduser", "updated@example.com", LocalDateTime.now(), "", UserRole.ADMIN);
User updatedUser = new User(testUserId, "updateduser", "updated@example.com", LocalDateTime.now(),
testUser.getPasswordHash(), UserRole.ADMIN);
when(userRepository.findById(testUserId)).thenReturn(Optional.of(testUser));
when(userRepository.save(any(User.class))).thenReturn(updatedUser);
// Act
User result = userService.updateUser(testUserId, updateData);
// Assert
assertNotNull(result);
assertEquals("updateduser", result.getUsername());
assertEquals(testUser.getPasswordHash(), result.getPasswordHash());
verify(userRepository, times(1)).findById(testUserId);
verify(passwordEncoder, never()).encode(anyString());
verify(userRepository, times(1)).save(any(User.class));
}
@Test
void deleteUser_ShouldCallRepositoryDelete() {
// Arrange
UUID userId = UUID.randomUUID();
doNothing().when(userRepository).deleteById(userId);
// Act
userService.deleteUser(userId);
// Assert
verify(userRepository, times(1)).deleteById(userId);
}
}

docker-compose.yml
services:
postgres:
image: postgres:16-alpine
container_name: calendar-postgres
environment:
POSTGRES_DB: calendardb
POSTGRES_USER: postgres
POSTGRES_PASSWORD: postgres
ports:
- '5432:5432'
volumes:
- postgres_data:/var/lib/postgresql/data
healthcheck:
test: ['CMD-SHELL', 'pg_isready -U postgres']
interval: 10s
timeout: 5s
retries: 5
networks:
- calendar-network
volumes:
postgres_data:
driver: local
networks:
calendar-network:
driver: bridge

eslint.config.mjs
import mantine from 'eslint-config-mantine';
import tseslint from 'typescript-eslint';
export default tseslint.config(...mantine, { ignores: ['**/*.{mjs,cjs,js,d.ts,d.mts}'] });

frontend/.env
VITE_API_URL=http://localhost:8080/api

frontend/eslint.config.js
import js from '@eslint/js';
import globals from 'globals';
import reactHooks from 'eslint-plugin-react-hooks';
import reactRefresh from 'eslint-plugin-react-refresh';
import tseslint from 'typescript-eslint';
import { defineConfig, globalIgnores } from 'eslint/config';
export default defineConfig([
globalIgnores(['dist']),
{
files: ['**/*.{ts,tsx}'],
extends: [
js.configs.recommended,
tseslint.configs.recommended,
reactHooks.configs.flat.recommended,
reactRefresh.configs.vite,
],
languageOptions: {
ecmaVersion: 2020,
globals: globals.browser,
},
},
]);

frontend/index.html
<!doctype html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<link rel="icon" type="image/png" href="/logo.png" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Заметки</title>
<meta name="description" content="Заметки" />
<meta name="keywords" content="заметки, notes, notes app, notes app" />
<meta name="author" content="Ilya" />
</head>
<body>
<div id="root"></div>
<script type="module" src="/src/main.tsx"></script>
</body>
</html>

frontend/package.json
{
"name": "frontend",
"private": true,
"version": "0.0.0",
"type": "module",
"scripts": {
"dev": "vite",
"build": "tsc -b && vite build",
"lint": "eslint .",
"preview": "vite preview"
},
"dependencies": {
"@mantine/core": "^8.3.10",
"@mantine/dates": "^8.3.10",
"@mantine/form": "^8.3.10",
"@mantine/hooks": "^8.3.10",
"@mantine/modals": "^8.3.10",
"@mantine/notifications": "^8.3.10",
"@tailwindcss/vite": "^4.1.18",
"@tanstack/react-query": "^5.90.12",
"@unhead/react": "^2.0.19",
"dayjs": "^1.11.19",
"mantine-form-zod-resolver": "^1.3.0",
"react": "^19.2.0",
"react-dom": "^19.2.0",
"react-router": "^7.11.0",
"tailwindcss": "^4.1.18",
"zod": "^4.2.1"
},
"devDependencies": {
"@eslint/js": "^9.39.1",
"@types/node": "^25.0.3",
"@types/react": "^19.2.5",
"@types/react-dom": "^19.2.3",
"@vitejs/plugin-react-swc": "^4.2.2",
"eslint": "^9.39.1",
"eslint-plugin-react-hooks": "^7.0.1",
"eslint-plugin-react-refresh": "^0.4.24",
"globals": "^16.5.0",
"postcss": "^8.5.6",
"postcss-preset-mantine": "^1.18.0",
"postcss-simple-vars": "^7.0.1",
"typescript": "~5.9.3",
"typescript-eslint": "^8.46.4",
"vite": "^7.2.4"
}
}

frontend/postcss.config.cjs
module.exports = {
plugins: {
'postcss-preset-mantine': {},
'postcss-simple-vars': {
variables: {
'mantine-breakpoint-xs': '36em',
'mantine-breakpoint-sm': '48em',
'mantine-breakpoint-md': '62em',
'mantine-breakpoint-lg': '75em',
'mantine-breakpoint-xl': '88em',
},
},
},
};

frontend/src/app/providers/Router.tsx
import { ProfilePage } from '@/pages/profile';
import { ErrorPage } from '@/pages/error';
import { AppLayout } from '@/widgets/app-layout';
import { DefaultLayout } from '@/widgets/default-layout';
import { ProtectedRoute } from '@/shared/ui/ProtectedRoute';
import { PublicRoute } from '@/shared/ui/PublicRoute';
import { lazy } from 'react';
import { createBrowserRouter, Navigate, RouterProvider } from 'react-router';
const LoginPage = lazy(() =>
import('@pages/auth/login').then((module) => ({ default: module.LoginPage })),
);
const RegisterPage = lazy(() =>
import('@pages/auth/register').then((module) => ({ default: module.RegisterPage })),
);
const InvintationsPage = lazy(() =>
import('@pages/invintations').then((module) => ({ default: module.InvintationsPage })),
);
const EventsPage = lazy(() =>
import('@pages/events').then((module) => ({ default: module.EventsPage })),
);
const EventPage = lazy(() =>
import('@pages/events').then((module) => ({ default: module.EventPage })),
);
const ContactsPage = lazy(() =>
import('@pages/contacts').then((module) => ({ default: module.ContactsPage })),
);
const AdminUsersPage = lazy(() =>
import('@pages/admin/users').then((module) => ({ default: module.AdminUsersPage })),
);
const router = createBrowserRouter([
{
path: '/',
element: (
<ProtectedRoute>
<AppLayout />
</ProtectedRoute>
),
errorElement: <ErrorPage />,
children: [
{
path: '/',
element: <Navigate to="/profile" replace />,
},
{
path: '/profile',
element: <ProfilePage />,
errorElement: <ErrorPage />,
},
{
path: '/invitations',
element: <InvintationsPage />,
errorElement: <ErrorPage />,
},
{
path: '/events',
element: <EventsPage />,
errorElement: <ErrorPage />,
},
{
path: '/events/:id',
element: <EventPage />,
errorElement: <ErrorPage />,
},
{
path: '/contacts',
element: <ContactsPage />,
errorElement: <ErrorPage />,
},
{
path: '/admin/users',
element: <AdminUsersPage />,
errorElement: <ErrorPage />,
},
],
},
{
path: '/login',
element: (
<PublicRoute>
<DefaultLayout />
</PublicRoute>
),
errorElement: <ErrorPage />,
children: [
{
index: true,
element: <LoginPage />,
errorElement: <ErrorPage />,
},
],
},
{
path: '/register',
element: (
<PublicRoute>
<DefaultLayout />
</PublicRoute>
),
errorElement: <ErrorPage />,
children: [
{
index: true,
element: <RegisterPage />,
errorElement: <ErrorPage />,
},
],
},
{
path: '*',
element: <ErrorPage />,
},
]);
const Router = () => {
return <RouterProvider router={router} />;
};
Router.displayName = 'RouterProvider';
export { Router };

frontend/src/app/providers/Theme.tsx
import { MantineProvider } from '@mantine/core';
import '@mantine/core/styles.css';
import '@mantine/dates/styles.css';
import '@mantine/notifications/styles.css';
import type { PropsWithChildren } from 'react';
import { ModalsProvider } from '@mantine/modals';
import { Notifications } from '@mantine/notifications';
const Theme = ({ children }: PropsWithChildren) => {
return (
<MantineProvider>
<ModalsProvider>
<Notifications />
{children}
</ModalsProvider>
</MantineProvider>
);
};
Theme.displayName = 'ThemeProvider';
export { Theme };

frontend/src/entities/contact/api/index.ts
import { apiClient } from '@/shared/api';
import type { ContactRequest, ContactRequestResponse } from '../model/types';
const contactApi = {
getContacts: async () => {
const response = await apiClient.get<ContactRequestResponse[]>('/contacts');
return response;
},
getContactById: async (id: string) => {
const response = await apiClient.get<ContactRequestResponse>(`/contacts/${id}`);
return response;
},
getUserContacts: async (userId: string) => {
const response = await apiClient.get<ContactRequestResponse[]>(`/contacts/user/${userId}`);
return response;
},
createContact: async (contact: ContactRequest) => {
const response = await apiClient.post('/contacts', contact);
return response;
},
updateContact: async (id: string, contact: ContactRequest) => {
const response = await apiClient.put(`/contacts/${id}`, contact);
return response;
},
deleteContact: async (id: string) => {
const response = await apiClient.delete(`/contacts/${id}`);
return response;
},
};
export { contactApi };

frontend/src/entities/contact/index.ts
export * from './model/hooks';
export * from './api';
export * from './model/types';

frontend/src/entities/contact/model/hooks.ts
import { useMutation, useQuery } from '@tanstack/react-query';
import { contactApi } from '../api';
import type { ContactRequest } from './types';
import { queryClient } from '@/shared/config';
const useContacts = () => {
return useQuery({ queryKey: ['contacts'], queryFn: () => contactApi.getContacts() });
};
const useContact = (id: string) => {
return useQuery({ queryKey: ['contact', id], queryFn: () => contactApi.getContactById(id) });
};
const useUserContacts = (userId: string) => {
return useQuery({
queryKey: ['userContacts', userId],
queryFn: () => contactApi.getUserContacts(userId),
});
};
const useCreateContact = () => {
return useMutation({
mutationFn: (contact: ContactRequest) => contactApi.createContact(contact),
onSuccess: () => {
queryClient.invalidateQueries({ queryKey: ['contacts'] });
queryClient.invalidateQueries({ queryKey: ['userContacts'] });
},
});
};
const useUpdateContact = () => {
return useMutation({
mutationFn: ({ id, contact }: { id: string; contact: ContactRequest }) =>
contactApi.updateContact(id, contact),
onSuccess: () => {
queryClient.invalidateQueries({ queryKey: ['contacts'] });
queryClient.invalidateQueries({ queryKey: ['userContacts'] });
},
});
};
const useDeleteContact = () => {
return useMutation({
mutationFn: (id: string) => contactApi.deleteContact(id),
onSuccess: () => {
queryClient.invalidateQueries({ queryKey: ['userContacts'] });
},
onError: () => {
queryClient.invalidateQueries({ queryKey: ['userContacts'] });
},
});
};
export {
useContacts,
useContact,
useUserContacts,
useCreateContact,
useUpdateContact,
useDeleteContact,
};

frontend/src/entities/contact/model/types.ts
const enum ContactRequestStatus {
PENDING = 'PENDING',
ACCEPTED = 'ACCEPTED',
REJECTED = 'REJECTED',
}
const ContactRequestStatusData = [
{ label: 'Ожидает', value: ContactRequestStatus.PENDING },
{ label: 'Принято', value: ContactRequestStatus.ACCEPTED },
{ label: 'Отклонено', value: ContactRequestStatus.REJECTED },
] as const;
interface ContactRequest {
createdAt: Date;
respondedAt: Date | null;
fromUserId: string;
toUserId: string;
status: ContactRequestStatus;
}
interface ContactRequestResponse {
id: string;
createdAt: Date;
respondedAt: Date | null;
fromUserId: string;
toUserId: string;
status: ContactRequestStatus;
}
export type { ContactRequest, ContactRequestResponse };
export { ContactRequestStatusData, ContactRequestStatus };

frontend/src/entities/event/api/index.ts
import { apiClient } from '@/shared/api';
import type { EventRequest, EventResponse } from '../model/types';
const eventApi = {
getEvents: async () => {
const response = await apiClient.get<EventResponse[]>('/events');
return response;
},
getEventById: async (id: string) => {
const response = await apiClient.get<EventResponse>(`/events/${id}`);
return response;
},
getUserEvents: async (userId: string) => {
const response = await apiClient.get<EventResponse[]>(`/events/user/${userId}`);
return response;
},
getInvitedEvents: async (userId: string) => {
const response = await apiClient.get<EventResponse[]>(`/events/invited/${userId}`);
return response;
},
createEvent: async (event: EventRequest) => {
const response = await apiClient.post('/events', event);
return response;
},
updateEvent: async (id: string, event: EventRequest) => {
const response = await apiClient.put(`/events/${id}`, event);
return response;
},
deleteEvent: async (id: string) => {
const response = await apiClient.delete(`/events/${id}`);
return response;
},
};
export { eventApi };

frontend/src/entities/event/index.ts
export * from './model/hooks';
export * from './api';
export * from './model/types';

frontend/src/entities/event/model/hooks.ts
import { useMutation, useQuery } from '@tanstack/react-query';
import { eventApi } from '../api';
import type { EventRequest } from './types';
import { queryClient } from '@/shared/config';
const useEvents = () => {
return useQuery({ queryKey: ['events'], queryFn: () => eventApi.getEvents() });
};
const useEvent = (id: string) => {
return useQuery({ queryKey: ['event', id], queryFn: () => eventApi.getEventById(id) });
};
const useUserEvents = (userId: string) => {
return useQuery({
queryKey: ['userEvents', userId],
queryFn: () => eventApi.getUserEvents(userId),
});
};
const useInvitedEvents = (userId: string) => {
return useQuery({
queryKey: ['invitedEvents', userId],
queryFn: () => eventApi.getInvitedEvents(userId),
});
};
const useCreateEvent = () => {
return useMutation({
mutationFn: (event: EventRequest) => eventApi.createEvent(event),
onSuccess: () => {
queryClient.invalidateQueries({ queryKey: ['events'] });
queryClient.invalidateQueries({ queryKey: ['userEvents'] });
queryClient.invalidateQueries({ queryKey: ['invitedEvents'] });
},
});
};
const useUpdateEvent = () => {
return useMutation({
mutationFn: ({ id, event }: { id: string; event: EventRequest }) =>
eventApi.updateEvent(id, event),
onSuccess: () => {
queryClient.invalidateQueries({ queryKey: ['events'] });
queryClient.invalidateQueries({ queryKey: ['event'] });
queryClient.invalidateQueries({ queryKey: ['userEvents'] });
queryClient.invalidateQueries({ queryKey: ['invitedEvents'] });
},
});
};
const useDeleteEvent = () => {
return useMutation({
mutationFn: (id: string) => eventApi.deleteEvent(id),
onSuccess: () => {
queryClient.invalidateQueries({ queryKey: ['userEvents'] });
queryClient.invalidateQueries({ queryKey: ['invitedEvents'] });
},
onError: () => {
queryClient.invalidateQueries({ queryKey: ['userEvents'] });
queryClient.invalidateQueries({ queryKey: ['invitedEvents'] });
},
});
};
export { useEvents, useEvent, useUserEvents, useInvitedEvents, useCreateEvent, useUpdateEvent, useDeleteEvent };

frontend/src/entities/event/model/types.ts
const enum EventStatus {
DRAFT = 'DRAFT',
PUBLISHED = 'PUBLISHED',
CANCELLED = 'CANCELLED',
}
const EventStatusData = [
{ label: 'Черновик', value: EventStatus.DRAFT },
{ label: 'Опубликовано', value: EventStatus.PUBLISHED },
{ label: 'Отменено', value: EventStatus.CANCELLED },
] as const;
// Статусы, доступные при создании события (без CANCELLED)
const EventStatusDataForCreation = [
{ label: 'Черновик', value: EventStatus.DRAFT },
{ label: 'Опубликовано', value: EventStatus.PUBLISHED },
] as const;
interface EventRequest {
title: string;
description: string;
startTime: Date;
endTime: Date;
ownerId: string;
status: EventStatus;
}
interface EventResponse {
id: string;
title: string;
description: string;
startTime: Date;
endTime: Date;
ownerId: string;
createdAt: Date;
status: EventStatus;
}
export type { EventRequest, EventResponse };
export { EventStatusData, EventStatusDataForCreation, EventStatus };

frontend/src/entities/invitation/api/index.ts
import { apiClient } from '@/shared/api';
import type { InvitationRequest, InvitationResponse } from '../model/types';
const invitationApi = {
getInvitations: async () => {
const response = await apiClient.get<InvitationResponse[]>('/invitations');
return response;
},
getInvitationById: async (id: string) => {
const response = await apiClient.get<InvitationResponse>(`/invitations/${id}`);
return response;
},
getUserInvitations: async (userId: string) => {
const response = await apiClient.get<InvitationResponse[]>(`/invitations/user/${userId}`);
return response;
},
createInvitation: async (invitation: InvitationRequest) => {
const response = await apiClient.post('/invitations', invitation);
return response;
},
updateInvitation: async (id: string, invitation: InvitationRequest) => {
const response = await apiClient.put(`/invitations/${id}`, invitation);
return response;
},
deleteInvitation: async (id: string) => {
const response = await apiClient.delete(`/invitations/${id}`);
return response;
},
};
export { invitationApi };

frontend/src/entities/invitation/index.ts
export * from './model/hooks';
export * from './api';
export * from './model/types';

frontend/src/entities/invitation/model/hooks.ts
import { useMutation, useQuery } from '@tanstack/react-query';
import { invitationApi } from '../api';
import type { InvitationRequest } from './types';
import { queryClient } from '@/shared/config';
const useInvitations = () => {
return useQuery({ queryKey: ['invitations'], queryFn: () => invitationApi.getInvitations() });
};
const useInvitation = (id: string) => {
return useQuery({
queryKey: ['invitation', id],
queryFn: () => invitationApi.getInvitationById(id),
});
};
const useUserInvitations = (userId: string) => {
return useQuery({
queryKey: ['userInvitations', userId],
queryFn: () => invitationApi.getUserInvitations(userId),
});
};
const useCreateInvitation = () => {
return useMutation({
mutationFn: (invitation: InvitationRequest) => invitationApi.createInvitation(invitation),
onSuccess: () => {
queryClient.invalidateQueries({ queryKey: ['invitations'] });
queryClient.invalidateQueries({ queryKey: ['userInvitations'] });
queryClient.invalidateQueries({ queryKey: ['invitedEvents'] });
},
});
};
const useUpdateInvitation = () => {
return useMutation({
mutationFn: ({ id, invitation }: { id: string; invitation: InvitationRequest }) =>
invitationApi.updateInvitation(id, invitation),
onSuccess: () => {
queryClient.invalidateQueries({ queryKey: ['invitations'] });
queryClient.invalidateQueries({ queryKey: ['userInvitations'] });
queryClient.invalidateQueries({ queryKey: ['invitedEvents'] });
},
});
};
const useDeleteInvitation = () => {
return useMutation({
mutationFn: (id: string) => invitationApi.deleteInvitation(id),
onSuccess: () => {
queryClient.invalidateQueries({ queryKey: ['invitations'] });
queryClient.invalidateQueries({ queryKey: ['userInvitations'] });
queryClient.invalidateQueries({ queryKey: ['invitedEvents'] });
},
});
};
export {
useInvitations,
useInvitation,
useUserInvitations,
useCreateInvitation,
useUpdateInvitation,
useDeleteInvitation,
};

frontend/src/entities/invitation/model/types.ts
const enum InvitationStatus {
PENDING = 'PENDING',
ACCEPTED = 'ACCEPTED',
REJECTED = 'REJECTED',
}
const InvitationStatusData = [
{ label: 'Ожидает', value: InvitationStatus.PENDING },
{ label: 'Принято', value: InvitationStatus.ACCEPTED },
{ label: 'Отклонено', value: InvitationStatus.REJECTED },
] as const;
interface InvitationRequest {
eventId: string;
userId: string;
status: InvitationStatus;
}
interface InvitationResponse {
id: string;
eventId: string;
userId: string;
createdAt: Date;
status: InvitationStatus;
}
export type { InvitationRequest, InvitationResponse };
export { InvitationStatusData, InvitationStatus };

frontend/src/entities/user/api/index.ts
import { apiClient } from '@/shared/api/client';
import type { UserCreate, UserLogin, UserResponse, UserUpdate } from '../model/types';
const userApi = {
getAllUsers: async () => {
const response = await apiClient.get<UserResponse[]>('/users');
return response;
},
getUserById: async (id: string) => {
const response = await apiClient.get<UserResponse>(`/users/${id}`);
return response;
},
updateUser: async (id: string, user: UserUpdate) => {
const response = await apiClient.put<UserResponse>(`/users/${id}`, user);
return response;
},
deleteUser: async (id: string) => {
const response = await apiClient.delete<void>(`/user/${id}`);
return response;
},
searchUsers: async (query: string, page: number = 0, size: number = 20) => {
const response = await apiClient.get<{
content: UserResponse[];
totalElements: number;
totalPages: number;
number: number;
size: number;
}>(`/users/search?q=${encodeURIComponent(query)}&page=${page}&size=${size}`);
return response;
},
};
const authApi = {
login: async (user: UserLogin) => {
const response = await apiClient.post('/auth/login', user);
return response;
},
register: async (user: UserCreate) => {
const response = await apiClient.post('/auth/register', user);
return response;
},
logout: async () => {
const response = await apiClient.post('/auth/logout', {});
return response;
},
refresh: async () => {
const response = await apiClient.post('/auth/refresh', {});
return response;
},
me: async () => {
const response = await apiClient.get<UserResponse>('/auth/me');
return response;
},
};
export { userApi, authApi };

frontend/src/entities/user/index.ts
export * from './model/types';
export * from './model/hooks';

frontend/src/entities/user/model/hooks.ts
import { useMutation, useQuery } from '@tanstack/react-query';
import { authApi, userApi } from '../api';
import type { UserCreate, UserLogin, UserUpdate } from './types';
import { queryClient } from '@/shared/config';
import { tokenStorage } from '@/shared/lib/token';
const useUsers = () => {
const query = useQuery({ queryKey: ['users'], queryFn: () => userApi.getAllUsers() });
return query;
};
const useUser = (id: string) => {
const query = useQuery({
queryKey: ['user', id],
queryFn: () => userApi.getUserById(id),
enabled: !!id,
});
return query;
};
const useUpdateUser = () => {
const mutation = useMutation({
mutationFn: ({ id, user }: { id: string; user: UserUpdate }) => userApi.updateUser(id, user),
onSuccess: () => {
queryClient.invalidateQueries({ queryKey: ['users'] });
queryClient.invalidateQueries({ queryKey: ['me'] });
queryClient.invalidateQueries({ queryKey: ['user'] });
},
});
return mutation;
};
const useDeleteUser = () => {
const mutation = useMutation({
mutationFn: (id: string) => userApi.deleteUser(id),
onSuccess: () => {
queryClient.invalidateQueries({ queryKey: ['users'] });
},
});
return mutation;
};
const useLogin = () => {
const mutation = useMutation({
mutationFn: (user: UserLogin) => authApi.login(user),
onSuccess: (data) => {
if (typeof data === 'object' && data !== null && 'accessToken' in data) {
tokenStorage.set(data.accessToken as string);
}
queryClient.invalidateQueries({ queryKey: ['user'] });
queryClient.invalidateQueries({ queryKey: ['users'] });
},
});
return mutation;
};
const useRegister = () => {
const mutation = useMutation({
mutationFn: (user: UserCreate) => authApi.register(user),
onSuccess: () => {
queryClient.invalidateQueries({ queryKey: ['user'] });
queryClient.invalidateQueries({ queryKey: ['users'] });
},
});
return mutation;
};
const useLogout = () => {
const mutation = useMutation({
mutationFn: async () => {
// Вызываем API для удаления refresh token cookie на сервере
try {
await authApi.logout();
} catch (error) {
// Игнорируем ошибки, так как мы все равно очищаем токены локально
console.error('Logout API error:', error);
}
// Удаляем access token из localStorage
tokenStorage.remove();
},
onSuccess: () => {
// Очищаем все кэшированные запросы
queryClient.clear();
},
});
return mutation;
};
const useRefresh = () => {
const mutation = useMutation({
mutationFn: () => authApi.refresh(),
onSuccess: (data) => {
if (
typeof data === 'object' &&
data &&
'accessToken' in data &&
data.accessToken &&
typeof data.accessToken === 'string'
) {
tokenStorage.set(data.accessToken);
}
queryClient.invalidateQueries({ queryKey: ['user'] });
queryClient.invalidateQueries({ queryKey: ['users'] });
},
});
return mutation;
};
const useMe = () => {
const query = useQuery({
queryKey: ['me'],
queryFn: () => authApi.me(),
enabled: tokenStorage.has(),
retry: false,
});
return query;
};
const useSearchUsers = (
query: string,
page: number = 0,
size: number = 20,
enabled: boolean = true,
) => {
return useQuery({
queryKey: ['searchUsers', query, page, size],
queryFn: () => userApi.searchUsers(query, page, size),
enabled: enabled && query.length >= 2,
retry: false,
});
};
export {
useUsers,
useUser,
useUpdateUser,
useDeleteUser,
useLogin,
useRegister,
useLogout,
useRefresh,
useMe,
useSearchUsers,
};

frontend/src/entities/user/model/types.ts
const enum UserRole {
ADMIN = 'ADMIN',
USER = 'USER',
}
interface UserCreate {
email: string;
username: string;
password: string;
}
interface UserLogin {
email: string;
password: string;
}
interface UserResponse {
id: string;
email: string;
username: string;
createdAt: Date;
updatedAt: Date;
role: UserRole;
}
interface UserUpdate {
email?: string;
username?: string;
password?: string;
role?: UserRole;
}
interface AuthResponse {
accessToken: string;
userId: string;
email: string;
username: string;
}
export type { AuthResponse, UserCreate, UserLogin, UserResponse, UserUpdate };
export { UserRole };

frontend/src/features/contact-form/index.ts
export { ContactForm } from './ui/ContactForm';

frontend/src/features/contact-form/ui/ContactForm.tsx
import { UserSearch } from '@/features/user-search';
import { useCreateContact, ContactRequestStatus } from '@/entities/contact';
import { useMe } from '@/entities/user';
import type { UserResponse } from '@/entities/user';
import { Stack, Button, Text } from '@mantine/core';
import { notifications } from '@mantine/notifications';
import { useState } from 'react';
type ContactFormProps = {
onSubmit: () => void;
};
const ContactForm = ({ onSubmit }: ContactFormProps) => {
const { data: currentUser } = useMe();
const { mutateAsync: createContact } = useCreateContact();
const [selectedUser, setSelectedUser] = useState<UserResponse | null>(null);
const [isSubmitting, setIsSubmitting] = useState(false);
const handleSelectUser = (user: UserResponse) => {
setSelectedUser(user);
};
const handleSubmit = async () => {
if (!selectedUser || !currentUser) {
notifications.show({
title: 'Ошибка',
message: 'Выберите пользователя',
color: 'red',
});
return;
}
setIsSubmitting(true);
try {
await createContact({
createdAt: new Date(),
respondedAt: null,
fromUserId: currentUser.id,
toUserId: selectedUser.id,
status: ContactRequestStatus.PENDING,
});
notifications.show({
title: 'Запрос отправлен',
message: `Запрос на добавление в контакты отправлен пользователю ${selectedUser.username}`,
color: 'green',
});
onSubmit();
} catch (error: unknown) {
console.error(error);
let errorMessage = 'Не удалось отправить запрос';
if (error instanceof Error && 'status' in error) {
const status = (error as Error & { status: number }).status;
if (status === 409) {
errorMessage = 'Запрос на добавление в контакты уже существует';
} else if (status === 400) {
errorMessage = 'Некорректные данные запроса';
}
}
notifications.show({
title: 'Ошибка',
message: errorMessage,
color: 'red',
});
} finally {
setIsSubmitting(false);
}
};
return (
<Stack gap="md">
<UserSearch
onSelectUser={handleSelectUser}
excludeUserIds={currentUser ? [currentUser.id] : []}
/>
{selectedUser && (
<Text size="sm" c="dimmed">
Выбран: {selectedUser.username} ({selectedUser.email})
</Text>
)}
<Button
onClick={handleSubmit}
disabled={!selectedUser || isSubmitting}
loading={isSubmitting}
>
Отправить запрос
</Button>
</Stack>
);
};
export { ContactForm };

frontend/src/features/event-form/index.ts
export * from './ui/EventFrom';

frontend/src/features/event-form/model/useEventForm.tsx
import { EventStatus, EventStatusDataForCreation } from '@/entities/event';
import { useForm } from '@mantine/form';
import { z } from 'zod';
import { zod4Resolver } from 'mantine-form-zod-resolver';
const eventFormSchema = z
.object({
title: z
.string({
error: 'Название события обязательно',
})
.min(1, 'Название события обязательно'),
description: z
.string({
error: 'Описание события обязательно',
})
.min(1, 'Описание события обязательно'),
startTime: z.date({
error: 'Дата начала события обязательна',
}),
endTime: z.date({
error: 'Дата окончания события обязательна',
}),
status: z.enum(EventStatusDataForCreation.map((status) => status.value)),
})
.refine((data) => data.endTime >= data.startTime, {
message: 'Время окончания события не может быть раньше времени начала',
path: ['endTime'],
});
const useEventForm = () => {
return useForm({
initialValues: {
title: '',
description: '',
startTime: new Date(),
endTime: new Date(),
status: EventStatus.DRAFT,
},
validate: zod4Resolver(eventFormSchema),
});
};
export { useEventForm };

frontend/src/features/event-form/ui/EventFrom.tsx
import { EventStatusDataForCreation, type EventRequest } from '@/entities/event';
import { Button, Select, Stack, Textarea, TextInput } from '@mantine/core';
import { DateTimePicker } from '@mantine/dates';
import { useEventForm } from '../model/useEventForm';
type EventFormProps = {
onSubmit: (values: Omit<EventRequest, 'ownerId'>) => void;
};
const EventForm = ({ onSubmit }: EventFormProps) => {
const form = useEventForm();
return (
<form onSubmit={form.onSubmit((values) => onSubmit(values))}>
<Stack gap="md">
<TextInput label="Название" {...form.getInputProps('title')} />
<Textarea label="Описание" {...form.getInputProps('description')} />
<DateTimePicker
label="Дата начала"
value={form.values.startTime}
onChange={(value) => form.setFieldValue('startTime', new Date(value ?? ''))}
error={form.errors.startTime}
valueFormat="DD MMMM YYYY HH:mm"
/>
<DateTimePicker
label="Дата окончания"
value={form.values.endTime}
onChange={(value) => form.setFieldValue('endTime', new Date(value ?? ''))}
error={form.errors.endTime}
valueFormat="DD MMMM YYYY HH:mm"
/>
<Select
label="Статус"
{...form.getInputProps('status')}
data={EventStatusDataForCreation.map((status) => ({
label: status.label,
value: status.value,
}))}
/>
<Button type="submit">Добавить</Button>
</Stack>
</form>
);
};
export { EventForm };

frontend/src/features/event-invite-form/index.ts
export { EventInviteForm } from './ui/EventInviteForm';

frontend/src/features/event-invite-form/ui/ContactInviteItem.tsx
import { useUser } from '@/entities/user';
import { nameToColor } from '@/shared/utils';
import { Group, Stack, Text, Avatar as MantineAvatar, Badge, Skeleton } from '@mantine/core';
import { IconUserCheck } from '@tabler/icons-react';
import { useMemo } from 'react';
type ContactInviteItemProps = {
contactUserId: string;
onInvite: () => void;
searchQuery: string;
};
const ContactInviteItem = ({ contactUserId, onInvite, searchQuery }: ContactInviteItemProps) => {
const { data: user, isLoading } = useUser(contactUserId);
const matchesSearch = useMemo(() => {
if (!searchQuery || searchQuery.length < 2) return true;
const query = searchQuery.toLowerCase();
return (
user?.username.toLowerCase().includes(query) || user?.email.toLowerCase().includes(query)
);
}, [user, searchQuery]);
if (isLoading) {
return <Skeleton height={60} />;
}
if (!matchesSearch) {
return null;
}
const userName = user?.username || contactUserId.slice(0, 8);
return (
<Group
gap="sm"
p="sm"
style={{
cursor: 'pointer',
borderRadius: '4px',
border: '1px solid var(--mantine-color-gray-3)',
}}
onClick={onInvite}
onMouseEnter={(e) => {
e.currentTarget.style.backgroundColor = 'var(--mantine-color-gray-0)';
}}
onMouseLeave={(e) => {
e.currentTarget.style.backgroundColor = 'transparent';
}}
>
<MantineAvatar name={userName} color={nameToColor(userName)} size="md" />
<Stack gap={2} style={{ flex: 1 }}>
<Text fw={500} size="sm">
{user?.username || 'Неизвестный пользователь'}
</Text>
{user?.email && (
<Text size="xs" c="dimmed">
{user.email}
</Text>
)}
</Stack>
<Badge leftSection={<IconUserCheck size={12} />} variant="light" color="blue">
Контакт
</Badge>
</Group>
);
};
export { ContactInviteItem };

frontend/src/features/event-invite-form/ui/ContactInviteList.tsx
import { Stack, Text, ScrollArea } from '@mantine/core';
import { ContactInviteItem } from './ContactInviteItem';
type ContactInviteListProps = {
contacts: Array<{ id: string; contactUserId: string }>;
onInvite: (userId: string) => void;
searchQuery: string;
};
const ContactInviteList = ({ contacts, onInvite, searchQuery }: ContactInviteListProps) => {
if (contacts.length === 0) {
return (
<Text c="dimmed" size="sm" ta="center" py="md">
Нет доступных контактов для приглашения
</Text>
);
}
return (
<ScrollArea h={400}>
<Stack gap="xs">
{contacts.map((contact) => (
<ContactInviteItem
key={contact.id}
contactUserId={contact.contactUserId}
onInvite={() => onInvite(contact.contactUserId)}
searchQuery={searchQuery}
/>
))}
</Stack>
</ScrollArea>
);
};
export { ContactInviteList };

frontend/src/features/event-invite-form/ui/ContactSearchInput.tsx
import { TextInput } from '@mantine/core';
import { IconSearch } from '@tabler/icons-react';
type ContactSearchInputProps = {
value: string;
onChange: (value: string) => void;
placeholder?: string;
};
const ContactSearchInput = ({
value,
onChange,
placeholder = 'Поиск контакта...',
}: ContactSearchInputProps) => {
return (
<TextInput
placeholder={placeholder}
value={value}
onChange={(e) => onChange(e.target.value)}
leftSection={<IconSearch size={16} />}
/>
);
};
export { ContactSearchInput };

frontend/src/features/event-invite-form/ui/EventInviteForm.tsx
import { useUserContacts, ContactRequestStatus } from '@/entities/contact';
import { useInvitations, useCreateInvitation, InvitationStatus } from '@/entities/invitation';
import { useMe } from '@/entities/user';
import { Stack, Skeleton } from '@mantine/core';
import { useDebouncedValue } from '@mantine/hooks';
import { notifications } from '@mantine/notifications';
import { useState, useMemo } from 'react';
import { ContactSearchInput } from './ContactSearchInput';
import { ContactInviteList } from './ContactInviteList';
type EventInviteFormProps = {
eventId: string;
onInvite: () => void;
};
const EventInviteForm = ({ eventId, onInvite }: EventInviteFormProps) => {
const { data: currentUser } = useMe();
const { data: contacts, isLoading: contactsLoading } = useUserContacts(currentUser?.id ?? '');
const { data: invitations, isLoading: invitationsLoading } = useInvitations();
const { mutateAsync: createInvitation } = useCreateInvitation();
const [searchQuery, setSearchQuery] = useState('');
const [debouncedSearch] = useDebouncedValue(searchQuery, 300);
const acceptedContacts = useMemo(() => {
if (!contacts || !currentUser) return [];
return contacts
.filter((contact) => contact.status === ContactRequestStatus.ACCEPTED)
.map((contact) => {
const contactUserId =
contact.fromUserId === currentUser.id ? contact.toUserId : contact.fromUserId;
return { ...contact, contactUserId };
});
}, [contacts, currentUser]);
const alreadyInvitedUserIds = useMemo(() => {
if (!invitations) return [];
return invitations
.filter((invitation) => invitation.eventId === eventId)
.map((invitation) => invitation.userId);
}, [invitations, eventId]);
const availableContacts = useMemo(() => {
return acceptedContacts.filter(
(contact) => !alreadyInvitedUserIds.includes(contact.contactUserId),
);
}, [acceptedContacts, alreadyInvitedUserIds]);
const handleInvite = async (userId: string) => {
try {
await createInvitation({
eventId,
userId,
status: InvitationStatus.PENDING,
});
notifications.show({
title: 'Приглашение отправлено',
message: 'Пользователь успешно приглашен на мероприятие',
color: 'green',
});
onInvite();
} catch (error) {
console.error(error);
notifications.show({
title: 'Ошибка',
message: 'Не удалось отправить приглашение',
color: 'red',
});
}
};
const isLoading = contactsLoading || invitationsLoading;
if (isLoading) {
return (
<Stack gap="md">
<Skeleton height={40} />
<Skeleton height={200} />
</Stack>
);
}
return (
<Stack gap="md">
<ContactSearchInput value={searchQuery} onChange={setSearchQuery} />
<ContactInviteList
contacts={availableContacts}
onInvite={handleInvite}
searchQuery={debouncedSearch}
/>
</Stack>
);
};
export { EventInviteForm };

frontend/src/features/event-invitees/index.ts
export { EventInvitees } from './ui/EventInvitees';

frontend/src/features/event-invitees/ui/EventInvitees.tsx
import { useInvitations, type InvitationResponse } from '@/entities/invitation';
import { useUser } from '@/entities/user';
import { getStatusColor, getStatusLabel, nameToColor } from '@/shared/utils';
import { EventInviteForm } from '@/features/event-invite-form';
import {
Card,
Stack,
Text,
Title,
Group,
Avatar as MantineAvatar,
Badge,
Skeleton,
Button,
} from '@mantine/core';
import { modals } from '@mantine/modals';
import { IconUsers, IconUserPlus } from '@tabler/icons-react';
import { useMemo } from 'react';
type EventInviteesProps = {
eventId: string;
};
const EventInvitees = ({ eventId }: EventInviteesProps) => {
const { data: invitations, isLoading } = useInvitations();
const eventInvitations = useMemo(() => {
if (!invitations) {
return [];
}
return invitations.filter((invitation) => invitation.eventId === eventId);
}, [invitations, eventId]);
const handleInviteClick = () => {
modals.open({
title: 'Пригласить пользователей',
children: (
<EventInviteForm
eventId={eventId}
onInvite={() => {
modals.closeAll();
}}
/>
),
});
};
if (isLoading) {
return (
<Card shadow="sm" padding="lg" radius="md" withBorder>
<Stack gap="md">
<Skeleton height={30} />
<Skeleton height={60} />
<Skeleton height={60} />
</Stack>
</Card>
);
}
return (
<Card shadow="sm" padding="lg" radius="md" withBorder>
<Stack gap="md">
<Group justify="space-between" align="center">
<Group gap="xs">
<IconUsers size={20} style={{ color: 'var(--mantine-color-blue-6)' }} />
<Title order={3}>Приглашенные</Title>
<Badge variant="light" size="lg">
{eventInvitations.length}
</Badge>
</Group>
<Button
leftSection={<IconUserPlus size={16} />}
size="sm"
variant="light"
onClick={handleInviteClick}
>
Пригласить
</Button>
</Group>
{eventInvitations.length === 0 ? (
<Text c="dimmed" size="sm">
Нет приглашенных пользователей
</Text>
) : (
<Stack gap="sm">
{eventInvitations.map((invitation) => (
<InviteeItem key={invitation.id} invitation={invitation} />
))}
</Stack>
)}
</Stack>
</Card>
);
};
type InviteeItemProps = {
invitation: InvitationResponse;
};
const InviteeItem = ({ invitation }: InviteeItemProps) => {
const { data: user, isLoading } = useUser(invitation.userId);
if (isLoading) {
return <Skeleton height={50} />;
}
const userName = user?.username || invitation.userId.slice(0, 8);
return (
<Group gap="sm" align="center">
<MantineAvatar name={userName} color={nameToColor(userName)} size="md" />
<Stack gap={2} style={{ flex: 1 }}>
<Text fw={500} size="sm">
{user?.username || 'Неизвестный пользователь'}
</Text>
{user?.email && (
<Text size="xs" c="dimmed">
{user.email}
</Text>
)}
</Stack>
<Badge color={getStatusColor(invitation.status)} variant="light" size="sm">
{getStatusLabel(invitation.status)}
</Badge>
</Group>
);
};
export { EventInvitees };

frontend/src/features/profile-edit-form/index.ts
export { ProfileEditForm } from './ui/ProfileEditForm';
export { useProfileEditForm, profileEditFormSchema } from './model/useProfileEditForm';
export type { ProfileEditFormValues } from './model/useProfileEditForm';

frontend/src/features/profile-edit-form/model/useProfileEditForm.ts
import { useForm } from '@mantine/form';
import { zod4Resolver } from 'mantine-form-zod-resolver';
import { z } from 'zod';
const profileEditFormSchema = z.object({
email: z
.string()
.refine(
(val) =>
val === '' || z.email({ message: 'Введите корректный email' }).safeParse(val).success,
{
message: 'Введите корректный email',
},
),
username: z.string().refine((val) => val === '' || val.length >= 3, {
message: 'Имя пользователя должно быть не менее 3 символов',
}),
password: z.string().refine((val) => val === '' || (val.length >= 8 && val.length <= 52), {
message: 'Пароль должен быть от 8 до 52 символов',
}),
});
export type ProfileEditFormValues = z.infer<typeof profileEditFormSchema>;
const createProfileEditFormSchema = (initialEmail: string, initialUsername: string) =>
z.object({
email: z
.string()
.refine(
(val) =>
val === initialEmail ||
(val !== '' && z.email({ message: 'Введите корректный email' }).safeParse(val).success),
{
message: 'Введите корректный email',
},
),
username: z
.string()
.refine((val) => val === initialUsername || (val !== '' && val.length >= 3), {
message: 'Имя пользователя должно быть не менее 3 символов',
}),
password: z.string().refine((val) => val === '' || (val.length >= 8 && val.length <= 52), {
message: 'Пароль должен быть от 8 до 52 символов',
}),
});
const useProfileEditForm = (initialData: { email: string; username: string }) => {
const schema = createProfileEditFormSchema(initialData.email, initialData.username);
return useForm({
initialValues: {
email: initialData.email,
username: initialData.username,
password: '',
},
validate: zod4Resolver(schema),
});
};
export { useProfileEditForm, profileEditFormSchema };

frontend/src/features/profile-edit-form/ui/ProfileEditForm.tsx
import { useUpdateUser, type UserUpdate } from '@/entities/user';
import { useProfileEditForm } from '../model/useProfileEditForm';
import { Button, Stack, TextInput, Group } from '@mantine/core';
import { IconMail, IconUser } from '@tabler/icons-react';
import { notifications } from '@mantine/notifications';
import { useState } from 'react';
type ProfileEditFormProps = {
initialData: { email: string; username: string };
userId: string;
onSuccess: () => void;
};
const ProfileEditForm = ({ initialData, userId, onSuccess }: ProfileEditFormProps) => {
const { mutateAsync: updateUser } = useUpdateUser();
const [isLoading, setIsLoading] = useState(false);
const form = useProfileEditForm(initialData);
const handleSubmit = async (values: typeof form.values) => {
setIsLoading(true);
try {
const updateData: UserUpdate = {
email: values.email === initialData.email ? initialData.email : values.email,
username: values.username === initialData.username ? initialData.username : values.username,
password: values.password || '',
};
await updateUser({ id: userId, user: updateData });
notifications.show({
title: 'Профиль обновлен',
message: 'Данные профиля успешно обновлены',
color: 'green',
});
onSuccess();
} catch (error) {
console.error(error);
notifications.show({
title: 'Ошибка',
message: 'Не удалось обновить профиль',
color: 'red',
});
} finally {
setIsLoading(false);
}
};
return (
<form onSubmit={form.onSubmit(handleSubmit)}>
<Stack gap="md">
<TextInput
label="Email"
placeholder="Введите email"
leftSection={<IconMail size={16} />}
{...form.getInputProps('email')}
/>
<TextInput
label="Имя пользователя"
placeholder="Введите имя пользователя"
leftSection={<IconUser size={16} />}
{...form.getInputProps('username')}
/>
<TextInput
label="Новый пароль (оставьте пустым, чтобы не менять)"
placeholder="Введите новый пароль"
type="password"
{...form.getInputProps('password')}
/>
<Group justify="flex-end" mt="md">
<Button variant="subtle" onClick={() => onSuccess()}>
Отмена
</Button>
<Button type="submit" loading={isLoading}>
Сохранить
</Button>
</Group>
</Stack>
</form>
);
};
export { ProfileEditForm };

frontend/src/features/user-search/index.ts
export { UserSearch } from './ui/UserSearch';

frontend/src/features/user-search/ui/UserSearch.tsx
import { useSearchUsers, type UserResponse } from '@/entities/user';
import { nameToColor } from '@/shared/utils';
import {
TextInput,
ScrollArea,
Stack,
Group,
Text,
Avatar as MantineAvatar,
Skeleton,
Button,
} from '@mantine/core';
import { useDebouncedValue } from '@mantine/hooks';
import { useState, useEffect } from 'react';
import { IconSearch } from '@tabler/icons-react';
type UserSearchProps = {
onSelectUser: (user: UserResponse) => void;
excludeUserIds?: string[];
};
const UserSearch = ({ onSelectUser, excludeUserIds = [] }: UserSearchProps) => {
const [query, setQuery] = useState('');
const [debouncedQuery] = useDebouncedValue(query, 300);
const [page, setPage] = useState(0);
const [accumulatedUsers, setAccumulatedUsers] = useState<UserResponse[]>([]);
const size = 20;
const shouldSearch = debouncedQuery.length >= 2;
const { data, isLoading, isFetching } = useSearchUsers(debouncedQuery, page, size, shouldSearch);
// Reset accumulated users when query changes
// This is a valid use case for syncing state with query results
useEffect(() => {
if (debouncedQuery.length >= 2 && page !== 0) {
setPage(0);
setAccumulatedUsers([]);
}
// eslint-disable-next-line
}, [debouncedQuery]);
// Accumulate users from paginated results
// This is a valid use case for syncing state with query results
useEffect(() => {
if (data?.content) {
if (page === 0) {
setAccumulatedUsers(data.content);
} else {
setAccumulatedUsers((prev) => {
const newUsers = data.content.filter((user) => !prev.some((u) => u.id === user.id));
return [...prev, ...newUsers];
});
}
}
// eslint-disable-next-line
}, [data?.content, page]);
const filteredUsers = accumulatedUsers.filter((user) => !excludeUserIds.includes(user.id));
const handleLoadMore = () => {
if (data && page < data.totalPages - 1) {
setPage((prev) => prev + 1);
}
};
const handleQueryChange = (value: string) => {
setQuery(value);
};
return (
<Stack gap="md">
<TextInput
placeholder="Введите username или email"
value={query}
onChange={(e) => handleQueryChange(e.target.value)}
leftSection={<IconSearch size={16} />}
/>
{debouncedQuery.length >= 2 && (
<ScrollArea h={300}>
<Stack gap="xs">
{isLoading && (
<>
{Array.from({ length: 3 }).map((_, index) => (
<Skeleton key={index} height={60} />
))}
</>
)}
{!isLoading && filteredUsers.length === 0 && (
<Text c="dimmed" ta="center" py="md">
Пользователи не найдены
</Text>
)}
{!isLoading &&
filteredUsers.map((user) => (
<Group
key={user.id}
p="sm"
style={{ cursor: 'pointer', borderRadius: '4px' }}
onClick={() => onSelectUser(user)}
onMouseEnter={(e) => {
e.currentTarget.style.backgroundColor = 'var(--mantine-color-gray-1)';
}}
onMouseLeave={(e) => {
e.currentTarget.style.backgroundColor = 'transparent';
}}
>
<MantineAvatar name={user.username} color={nameToColor(user.username)} />
<Stack gap={0} style={{ flex: 1 }}>
<Text fw={500}>{user.username}</Text>
<Text size="sm" c="dimmed">
{user.email}
</Text>
</Stack>
</Group>
))}
{!isLoading && data && page < data.totalPages - 1 && (
<Button variant="light" onClick={handleLoadMore} loading={isFetching} fullWidth>
Загрузить еще
</Button>
)}
</Stack>
</ScrollArea>
)}
{debouncedQuery.length < 2 && debouncedQuery.length > 0 && (
<Text c="dimmed" ta="center" py="md">
Введите минимум 2 символа для поиска
</Text>
)}
</Stack>
);
};
export { UserSearch };

frontend/src/index.css
@import 'tailwindcss';

frontend/src/main.tsx
import { StrictMode, type ErrorInfo } from 'react';
import { createRoot } from 'react-dom/client';
import './index.css';
import { Theme } from './app/providers/Theme.tsx';
import { Router } from './app/providers/Router.tsx';
import { QueryClientProvider } from '@tanstack/react-query';
import { queryClient } from './shared/config';
import { createHead, UnheadProvider } from '@unhead/react/client';
const head = createHead();
createRoot(document.getElementById('root')!, {
onCaughtError: (error: unknown, errorInfo: ErrorInfo) => {
if (error instanceof Error && error.message !== 'Known error') {
console.error('Caught error');
console.error(error);
console.error(errorInfo);
}
},
onUncaughtError(error, errorInfo) {
if (error instanceof Error && error.message !== 'Known error') {
console.error('Uncaught error');
console.error(error);
console.error(errorInfo);
}
},
}).render(
<StrictMode>
<UnheadProvider head={head}>
<QueryClientProvider client={queryClient}>
<Theme>
<Router />
</Theme>
</QueryClientProvider>
</UnheadProvider>
</StrictMode>,
);

frontend/src/pages/admin/users/index.ts
export { AdminUsersPage } from './ui/AdminUsersPage';

frontend/src/pages/admin/users/ui/AdminUsersPage.tsx
import { useUsers, useUpdateUser, useMe, UserRole } from '@/entities/user';
import { formatDateTime } from '@/shared/utils';
import {
Stack,
Group,
Title,
Text,
Skeleton,
Badge,
Select,
SimpleGrid,
Table,
Paper,
Center,
} from '@mantine/core';
import { IconUser } from '@tabler/icons-react';
import { useHead } from '@unhead/react';
import { notifications } from '@mantine/notifications';
import { Navigate } from 'react-router';
const SYSTEM_ADMIN_EMAIL = 'admin@system.local';
const AdminUsersPage = () => {
useHead({
title: 'Управление пользователями',
meta: [
{
name: 'description',
content: 'Страница управления пользователями',
},
],
});
const { data: currentUser, isLoading: isCurrentUserLoading } = useMe();
const { data: users, isLoading } = useUsers();
const { mutateAsync: updateUser } = useUpdateUser();
// Проверяем, является ли пользователь админом
if (isCurrentUserLoading) {
return (
<Stack gap="xl">
<Title order={1}>Управление пользователями</Title>
<Center>
<Skeleton height={50} width="100%" />
</Center>
</Stack>
);
}
if (!currentUser || currentUser.role !== UserRole.ADMIN) {
return <Navigate to="/profile" replace />;
}
const handleRoleChange = async (userId: string, newRole: UserRole, userEmail: string) => {
// Запрещаем редактировать системного пользователя
if (userEmail === SYSTEM_ADMIN_EMAIL) {
notifications.show({
title: 'Ошибка',
message: 'Нельзя изменить роль системного пользователя',
color: 'red',
});
return;
}
// Запрещаем админу менять свою роль
if (currentUser?.id === userId) {
notifications.show({
title: 'Ошибка',
message: 'Вы не можете изменить свою роль',
color: 'red',
});
return;
}
try {
await updateUser({
id: userId,
user: { role: newRole },
});
notifications.show({
title: 'Роль обновлена',
message: 'Роль пользователя успешно изменена',
color: 'green',
});
} catch (error) {
console.error(error);
notifications.show({
title: 'Ошибка',
message: 'Не удалось изменить роль пользователя',
color: 'red',
});
}
};
if (isLoading) {
return (
<Stack gap="xl">
<Title order={1}>Управление пользователями</Title>
<SimpleGrid cols={{ base: 1, sm: 2, lg: 3 }} spacing="md">
{Array.from({ length: 6 }).map((_, index) => (
<Skeleton key={index} height={200} />
))}
</SimpleGrid>
</Stack>
);
}
if (!users || users.length === 0) {
return (
<Stack gap="xl">
<Title order={1}>Управление пользователями</Title>
<Text c="dimmed">Нет пользователей</Text>
</Stack>
);
}
return (
<Stack gap="xl">
<Title order={1}>Управление пользователями</Title>
<Paper withBorder shadow="sm" p="md" radius="md">
<Table>
<Table.Thead>
<Table.Tr>
<Table.Th>Пользователь</Table.Th>
<Table.Th>Email</Table.Th>
<Table.Th>Дата регистрации</Table.Th>
<Table.Th>Текущая роль</Table.Th>
<Table.Th>Изменить роль</Table.Th>
</Table.Tr>
</Table.Thead>
<Table.Tbody>
{users.map((user) => (
<Table.Tr key={user.id}>
<Table.Td>
<Group gap="xs">
<IconUser size={20} />
<Text fw={500}>{user.username}</Text>
</Group>
</Table.Td>
<Table.Td>
<Text size="sm">{user.email}</Text>
</Table.Td>
<Table.Td>
<Text size="sm">{formatDateTime(user.createdAt)}</Text>
</Table.Td>
<Table.Td>
<Badge color={user.role === UserRole.ADMIN ? 'red' : 'blue'} variant="light">
{user.role === UserRole.ADMIN ? 'Администратор' : 'Пользователь'}
</Badge>
</Table.Td>
<Table.Td>
<Select
data={[
{ label: 'Пользователь', value: UserRole.USER },
{ label: 'Администратор', value: UserRole.ADMIN },
]}
value={user.role}
onChange={(value) => {
if (value) {
handleRoleChange(user.id, value as UserRole, user.email);
}
}}
disabled={currentUser?.id === user.id || user.email === SYSTEM_ADMIN_EMAIL}
w={200}
/>
</Table.Td>
</Table.Tr>
))}
</Table.Tbody>
</Table>
</Paper>
</Stack>
);
};
AdminUsersPage.displayName = 'AdminUsersPage';
export { AdminUsersPage };

frontend/src/pages/auth/login/index.ts
export { LoginPage } from './ui/LoginPage';

frontend/src/pages/auth/login/model/index.ts
import { useForm } from '@mantine/form';
import { z } from 'zod';
import { zod4Resolver } from 'mantine-form-zod-resolver';
const loginFormSchema = z.object({
email: z.email({
error: 'Введите корректный email',
}),
password: z
.string({
error: 'Введите пароль',
})
.min(8, {
message: 'Пароль должен быть не менее 8 символов',
}),
});
const useLoginForm = () => {
const form = useForm({
initialValues: {
email: '',
password: '',
},
validate: zod4Resolver(loginFormSchema),
});
return form;
};
export { useLoginForm, loginFormSchema };

frontend/src/pages/auth/login/ui/LoginPage.tsx
import { Button, Card, Group, PasswordInput, Stack, TextInput, Title } from '@mantine/core';
import { useHead } from '@unhead/react';
import { loginFormSchema, useLoginForm } from '../model';
import { z } from 'zod';
import { Link, useNavigate } from 'react-router';
import { notifications } from '@mantine/notifications';
import { useLogin } from '@/entities/user';
const LoginPage = () => {
useHead({
title: 'Логин',
meta: [
{
name: 'description',
content: 'Страница входа в систему',
},
],
});
const { mutateAsync: login, isPending } = useLogin();
const navigate = useNavigate();
const handleSubmit = async (values: z.infer<typeof loginFormSchema>) => {
try {
await login(values);
notifications.show({
title: 'Успешно',
message: 'Вы успешно вошли в систему',
color: 'green',
});
navigate('/');
} catch (error) {
console.error(error);
notifications.show({
title: 'Ошибка',
message: 'Не удалось войти',
color: 'red',
});
}
};
const form = useLoginForm();
return (
<>
<Card withBorder shadow="sm" radius="md" miw="50%" mih="70%" p="xl">
<Card.Section withBorder inheritPadding py="xs">
<Stack>
<Title order={2} ta="center" fw={700} size="xl">
Войдите в систему
</Title>
<form onSubmit={form.onSubmit(handleSubmit)} className="flex flex-col gap-4">
<TextInput {...form.getInputProps('email')} label="Email" placeholder="email" />
<PasswordInput
{...form.getInputProps('password')}
label="Пароль"
placeholder="пароль"
/>
<Button loading={isPending} type="submit">
Войти
</Button>
</form>
<Group justify="center">
<Link to="/register">Зарегистрироваться</Link>
</Group>
</Stack>
</Card.Section>
</Card>
</>
);
};
LoginPage.displayName = 'LoginPage';
export { LoginPage };

frontend/src/pages/auth/register/index.ts
export { RegisterPage } from './ui/RegisterPage';

frontend/src/pages/auth/register/model/index.ts
import { useForm } from '@mantine/form';
import { zod4Resolver } from 'mantine-form-zod-resolver';
import z from 'zod';
const registerFormSchema = z.object({
email: z.email({
message: 'Введите корректный email',
}),
username: z.string().min(3, {
message: 'Имя пользователя должно быть не менее 3 символов',
}),
password: z.string().min(8, {
message: 'Пароль должен быть не менее 8 символов',
}),
});
const useRegisterForm = () => {
const form = useForm({
initialValues: {
email: '',
username: '',
password: '',
},
validate: zod4Resolver(registerFormSchema),
});
return form;
};
export { useRegisterForm, registerFormSchema };

frontend/src/pages/auth/register/ui/RegisterPage.tsx
import { Button, Card, Group, PasswordInput, Stack, TextInput, Title } from '@mantine/core';
import { registerFormSchema, useRegisterForm } from '../model';
import { useHead } from '@unhead/react';
import { z } from 'zod';
import { Link } from 'react-router';
import { useRegister } from '@/entities/user';
import { notifications } from '@mantine/notifications';
import { useNavigate } from 'react-router';
const RegisterPage = () => {
useHead({
title: 'Регистрация',
meta: [
{
name: 'description',
content: 'Страница регистрации',
},
],
});
const form = useRegisterForm();
const { mutateAsync: register, isPending } = useRegister();
const navigate = useNavigate();
const handleSubmit = async (values: z.infer<typeof registerFormSchema>) => {
try {
await register(values);
notifications.show({
title: 'Успешно',
message: 'Вы успешно зарегистрированы',
color: 'green',
});
navigate('/login');
} catch (error) {
console.error(error);
notifications.show({
title: 'Ошибка',
message: 'Не удалось зарегистрироваться',
color: 'red',
});
}
};
return (
<Card withBorder shadow="sm" radius="md" miw="50%" mih="70%" p="xl">
<Card.Section withBorder inheritPadding py="xs">
<Stack>
<Title order={2} ta="center" fw={700} size="xl">
Зарегистрироваться
</Title>
<form onSubmit={form.onSubmit(handleSubmit)} className="flex flex-col gap-4">
<TextInput {...form.getInputProps('email')} label="Email" placeholder="email" />
<TextInput
{...form.getInputProps('username')}
label="Придумайте крутое имя"
placeholder="ваш никнейм"
/>
<PasswordInput
{...form.getInputProps('password')}
label="Пароль"
placeholder="пароль"
/>
<Button loading={isPending} type="submit">
Зарегистрироваться
</Button>
</form>
<Group justify="center">
<Link to="/login">Уже зарегистрированы? Войдите</Link>
</Group>
</Stack>
</Card.Section>
</Card>
);
};
RegisterPage.displayName = 'RegisterPage';
export { RegisterPage };

frontend/src/pages/contacts/index.ts
export { ContactsPage } from './ui/ContactsPage';

frontend/src/pages/contacts/ui/ContactsPage.tsx
import {
ContactRequestStatus,
useUserContacts,
useUpdateContact,
type ContactRequestResponse,
useDeleteContact,
} from '@/entities/contact';
import { useMe, useUser } from '@/entities/user';
import { nameToColor } from '@/shared/utils';
import { ContactForm } from '@/features/contact-form';
import {
Button,
Card,
Group,
Stack,
Title,
Text,
Skeleton,
SimpleGrid,
Pill,
Avatar as MantineAvatar,
Tabs,
Tooltip,
ActionIcon,
} from '@mantine/core';
import { modals } from '@mantine/modals';
import { notifications } from '@mantine/notifications';
import { useHead } from '@unhead/react';
import { useMemo } from 'react';
import { IconX } from '@tabler/icons-react';
const ContactsPage = () => {
useHead({
title: 'Контакты',
meta: [
{
name: 'description',
content: 'Страница контактов',
},
],
});
const { data: user } = useMe();
const { data: contacts, isLoading } = useUserContacts(user?.id ?? '');
const { mutateAsync: updateContact } = useUpdateContact();
const { acceptedContacts, incomingRequests, outgoingRequests } = useMemo(() => {
if (!contacts || !user) {
return { acceptedContacts: [], incomingRequests: [], outgoingRequests: [] };
}
const accepted = contacts
.filter((contact) => contact.status === ContactRequestStatus.ACCEPTED)
.map((contact) => {
const contactUserId =
contact.fromUserId === user.id ? contact.toUserId : contact.fromUserId;
return { ...contact, contactUserId };
});
const incoming = contacts.filter(
(contact) => contact.toUserId === user.id && contact.status === ContactRequestStatus.PENDING,
);
const outgoing = contacts.filter(
(contact) =>
contact.fromUserId === user.id && contact.status === ContactRequestStatus.PENDING,
);
return { acceptedContacts: accepted, incomingRequests: incoming, outgoingRequests: outgoing };
}, [contacts, user]);
const handleCreateContact = () => {
modals.open({
title: 'Добавить контакт',
children: (
<ContactForm
onSubmit={() => {
modals.closeAll();
}}
/>
),
});
};
const handleAcceptRequest = async (contact: ContactRequestResponse) => {
try {
await updateContact({
id: contact.id,
contact: {
createdAt: contact.createdAt,
respondedAt: new Date(),
fromUserId: contact.fromUserId,
toUserId: contact.toUserId,
status: ContactRequestStatus.ACCEPTED,
},
});
notifications.show({
title: 'Запрос принят',
message: 'Контакт успешно добавлен',
color: 'green',
});
} catch (error) {
console.error(error);
notifications.show({
title: 'Ошибка',
message: 'Не удалось принять запрос',
color: 'red',
});
}
};
const handleRejectRequest = async (contact: ContactRequestResponse) => {
try {
await updateContact({
id: contact.id,
contact: {
createdAt: contact.createdAt,
respondedAt: new Date(),
fromUserId: contact.fromUserId,
toUserId: contact.toUserId,
status: ContactRequestStatus.REJECTED,
},
});
notifications.show({
title: 'Запрос отклонен',
message: 'Запрос на добавление в контакты отклонен',
color: 'blue',
});
} catch (error) {
console.error(error);
notifications.show({
title: 'Ошибка',
message: 'Не удалось отклонить запрос',
color: 'red',
});
}
};
return (
<Stack gap="xl">
<Group justify="space-between">
<Title order={1}>Контакты</Title>
<Button onClick={handleCreateContact}>Добавить контакт</Button>
</Group>
{isLoading && (
<Stack gap="md">
{Array.from({ length: 3 }).map((_, index) => (
<Skeleton key={index} height={150} />
))}
</Stack>
)}
{!isLoading && (
<Tabs defaultValue="accepted">
<Tabs.List>
<Tabs.Tab value="accepted">Мои контакты ({acceptedContacts.length})</Tabs.Tab>
<Tabs.Tab value="incoming">Входящие запросы ({incomingRequests.length})</Tabs.Tab>
<Tabs.Tab value="outgoing">Исходящие запросы ({outgoingRequests.length})</Tabs.Tab>
</Tabs.List>
<Tabs.Panel value="accepted" pt="xs">
{acceptedContacts.length === 0 ? (
<Text c="dimmed">Нет контактов</Text>
) : (
<SimpleGrid cols={{ base: 1, sm: 2 }} spacing="md">
{acceptedContacts.map((contact) => (
<ContactCard key={contact.id} contactUserId={contact.contactUserId} />
))}
</SimpleGrid>
)}
</Tabs.Panel>
<Tabs.Panel value="incoming" pt="xs">
{incomingRequests.length === 0 ? (
<Text c="dimmed">Нет входящих запросов</Text>
) : (
<SimpleGrid cols={{ base: 1, sm: 2 }} spacing="md">
{incomingRequests.map((contact) => (
<IncomingRequestCard
key={contact.id}
contact={contact}
onAccept={() => handleAcceptRequest(contact)}
onReject={() => handleRejectRequest(contact)}
/>
))}
</SimpleGrid>
)}
</Tabs.Panel>
<Tabs.Panel value="outgoing" pt="xs">
{outgoingRequests.length === 0 ? (
<Text c="dimmed">Нет исходящих запросов</Text>
) : (
<SimpleGrid cols={{ base: 1, sm: 2 }} spacing="md">
{outgoingRequests.map((contact) => (
<OutgoingRequestCard key={contact.id} contact={contact} />
))}
</SimpleGrid>
)}
</Tabs.Panel>
</Tabs>
)}
</Stack>
);
};
type ContactCardProps = {
contactUserId: string;
};
const ContactCard = ({ contactUserId }: ContactCardProps) => {
const { data: contactUser } = useUser(contactUserId);
const { mutateAsync: deleteContactMutation } = useDeleteContact();
const contactName = contactUser?.username || contactUserId.slice(0, 8);
const handleDeleteContact = async (contactId: string) => {
modals.openConfirmModal({
title: `Удалить контакт ${contactName}?`,
children: <Text size="sm">Вы уверены, что хотите удалить контакт {contactName}?</Text>,
labels: { confirm: 'Удалить', cancel: 'Отмена' },
onCancel: () => console.log('Отмена'),
onConfirm: async () => {
try {
await deleteContactMutation(contactId);
notifications.show({
title: 'Контакт удален',
message: 'Контакт успешно удален',
color: 'green',
icon: <IconX size={16} />,
});
} catch (error) {
console.error(error);
notifications.show({
title: 'Ошибка',
message: 'Не удалось удалить контакт',
color: 'red',
icon: <IconX size={16} />,
});
}
},
});
};
return (
<Card withBorder shadow="sm" padding="lg" radius="md">
<Group>
<MantineAvatar name={contactName} color={nameToColor(contactName)} size="lg" />
<Stack gap="xs" style={{ flex: 1 }}>
<Text fw={600} size="lg">
{contactUser?.username || 'Неизвестный пользователь'}
</Text>
<Text size="sm" c="dimmed">
{contactUser?.email || 'Email не указан'}
</Text>
</Stack>
<Tooltip label="Удалить контакт">
<ActionIcon onClick={() => handleDeleteContact(contactUserId)}>
<IconX size={16} />
</ActionIcon>
</Tooltip>
</Group>
</Card>
);
};
type IncomingRequestCardProps = {
contact: ContactRequestResponse;
onAccept: () => void;
onReject: () => void;
};
const IncomingRequestCard = ({ contact, onAccept, onReject }: IncomingRequestCardProps) => {
const { data: contactUser } = useUser(contact.fromUserId);
const contactName = contactUser?.username || contact.fromUserId.slice(0, 8);
return (
<Card withBorder shadow="sm" padding="lg" radius="md">
<Stack gap="sm">
<Group>
<MantineAvatar name={contactName} color={nameToColor(contactName)} size="lg" />
<Stack gap="xs" style={{ flex: 1 }}>
<Text fw={600} size="lg">
{contactUser?.username || 'Неизвестный пользователь'}
</Text>
<Text size="sm" c="dimmed">
{contactUser?.email || 'Email не указан'}
</Text>
<Text size="xs" c="dimmed">
Отправлен: {new Date(contact.createdAt).toLocaleString('ru-RU')}
</Text>
</Stack>
</Group>
<Group>
<Button color="green" onClick={onAccept} size="sm">
Принять
</Button>
<Button color="red" variant="outline" onClick={onReject} size="sm">
Отклонить
</Button>
</Group>
</Stack>
</Card>
);
};
type OutgoingRequestCardProps = {
contact: ContactRequestResponse;
};
const OutgoingRequestCard = ({ contact }: OutgoingRequestCardProps) => {
const { data: contactUser } = useUser(contact.toUserId);
const contactName = contactUser?.username || contact.toUserId.slice(0, 8);
return (
<Card withBorder shadow="sm" padding="lg" radius="md">
<Group align="flex-start">
<MantineAvatar name={contactName} color={nameToColor(contactName)} size="lg" />
<Stack gap="xs" style={{ flex: 1 }}>
<Text fw={600} size="lg">
{contactUser?.username || 'Неизвестный пользователь'}
</Text>
<Text size="sm" c="dimmed">
{contactUser?.email || 'Email не указан'}
</Text>
<Text size="xs" c="dimmed">
Отправлен: {new Date(contact.createdAt).toLocaleString('ru-RU')}
</Text>
<Pill color="yellow" variant="light" maw="fit-content">
Ожидает ответа
</Pill>
</Stack>
<Tooltip label="Отменить запрос">
<ActionIcon>
<IconX size={16} />
</ActionIcon>
</Tooltip>
</Group>
</Card>
);
};
ContactsPage.displayName = 'ContactsPage';
export { ContactsPage };

frontend/src/pages/error/index.ts
export { ErrorPage } from './ui/ErrorPage';

frontend/src/pages/error/ui/ErrorPage.tsx
import { Button, Stack, Title, Text, Card, Group, Center } from '@mantine/core';
import {
IconAlertCircle,
IconLock,
IconFileInfo,
IconServer,
IconHome,
IconArrowLeft,
} from '@tabler/icons-react';
import { useHead } from '@unhead/react';
import { useNavigate, useRouteError, isRouteErrorResponse } from 'react-router';
import type { JSX } from 'react';
type ErrorType = '404' | '403' | '500' | 'unknown';
const getErrorInfo = (
error: unknown,
): { type: ErrorType; title: string; message: string; icon: JSX.Element } => {
if (isRouteErrorResponse(error)) {
const status = error.status;
if (status === 404) {
return {
type: '404',
title: 'Страница не найдена',
message:
'К сожалению, запрашиваемая страница не существует. Возможно, она была удалена или перемещена.',
icon: <IconFileInfo size={64} stroke={1.5} />,
};
}
if (status === 403) {
return {
type: '403',
title: 'Доступ запрещен',
message:
'У вас нет прав для доступа к этому ресурсу. Обратитесь к администратору, если считаете, что это ошибка.',
icon: <IconLock size={64} stroke={1.5} />,
};
}
if (status >= 500) {
return {
type: '500',
title: 'Ошибка сервера',
message:
'Произошла внутренняя ошибка сервера. Мы уже работаем над решением проблемы. Попробуйте позже.',
icon: <IconServer size={64} stroke={1.5} />,
};
}
}
if (error instanceof Error) {
if (error.message.includes('404') || error.message.includes('not found')) {
return {
type: '404',
title: 'Страница не найдена',
message: 'К сожалению, запрашиваемая страница не существует.',
icon: <IconFileInfo size={64} stroke={1.5} />,
};
}
if (error.message.includes('403') || error.message.includes('forbidden')) {
return {
type: '403',
title: 'Доступ запрещен',
message: 'У вас нет прав для доступа к этому ресурсу.',
icon: <IconLock size={64} stroke={1.5} />,
};
}
}
return {
type: 'unknown',
title: 'Произошла ошибка',
message: 'Что-то пошло не так. Попробуйте обновить страницу или вернуться на главную.',
icon: <IconAlertCircle size={64} stroke={1.5} />,
};
};
const ErrorPage = () => {
const error = useRouteError();
const navigate = useNavigate();
const errorInfo = getErrorInfo(error);
useHead({
title: errorInfo.title || errorInfo.type,
meta: [
{
name: 'description',
content: errorInfo.message,
},
],
});
const getColor = () => {
switch (errorInfo.type) {
case '404':
return 'blue';
case '403':
return 'red';
case '500':
return 'orange';
default:
return 'gray';
}
};
return (
<Center h="100vh" p="md">
<Card withBorder shadow="md" padding="xl" radius="md" maw={600} w="100%">
<Stack gap="xl" align="center">
<div style={{ color: `var(--mantine-color-${getColor()}-6)` }}>{errorInfo.icon}</div>
<Stack gap="xs" align="center">
<Title order={1} ta="center">
{errorInfo.title}
</Title>
<Text c="dimmed" ta="center" size="lg">
{errorInfo.message}
</Text>
</Stack>
<Group justify="center" mt="md">
<Button
leftSection={<IconArrowLeft size={18} />}
variant="light"
onClick={() => navigate(-1)}
>
Назад
</Button>
<Button leftSection={<IconHome size={18} />} onClick={() => navigate('/')}>
На главную
</Button>
</Group>
{import.meta.env.DEV && error instanceof Error && (
<Card
withBorder
padding="md"
radius="md"
w="100%"
style={{ backgroundColor: 'var(--mantine-color-gray-0)' }}
>
<Stack gap="xs">
<Text size="sm" fw={600}>
Детали ошибки (только в режиме разработки):
</Text>
<Text
size="xs"
c="dimmed"
style={{ fontFamily: 'monospace', wordBreak: 'break-all' }}
>
{error.message}
{error.stack && (
<pre
style={{
marginTop: 8,
fontSize: '10px',
overflow: 'auto',
maxHeight: '200px',
}}
>
{error.stack}
</pre>
)}
</Text>
</Stack>
</Card>
)}
</Stack>
</Card>
</Center>
);
};
ErrorPage.displayName = 'ErrorPage';
export { ErrorPage };

frontend/src/pages/events/index.ts
export { EventsPage } from './ui/EventsPage';
export { EventPage } from './ui/EventPage';

frontend/src/pages/events/model/index.ts
import { useForm } from '@mantine/form';
import { z } from 'zod';
import { EventStatusData } from '@/entities/event';
import { EventStatus } from '@/entities/event';
import { zod4Resolver } from 'mantine-form-zod-resolver';
const updateEventFormSchema = z.object({
title: z.string().min(1, 'Название события обязательно'),
description: z.string().min(1, 'Описание события обязательно'),
startTime: z.date(),
endTime: z.date(),
status: z.enum(EventStatusData.map((status) => status.value)),
});
const useUpdateEventForm = () => {
return useForm({
initialValues: {
title: '',
description: '',
startTime: new Date(),
endTime: new Date(),
status: EventStatus.DRAFT,
},
validate: zod4Resolver(updateEventFormSchema),
});
};
export { useUpdateEventForm, updateEventFormSchema };

frontend/src/pages/events/ui/EventPage.tsx
import { useEvent, useUpdateEvent, EventStatus } from '@/entities/event';
import { useMe } from '@/entities/user';
import { useUser } from '@/entities/user';
import {
formatDateTime,
getEventStatusLabel,
getEventStatusColor,
getEventState,
getEventStateLabel,
getEventStateColor,
} from '@/shared/utils';
import { EventInvitees } from '@/features/event-invitees';
import {
Button,
Skeleton,
Stack,
Text,
Title,
Card,
Group,
Badge,
Divider,
Paper,
Box,
Grid,
} from '@mantine/core';
import {
IconCalendar,
IconClock,
IconUser,
IconFileText,
IconTag,
IconArrowLeft,
IconCheck,
IconX,
IconEye,
} from '@tabler/icons-react';
import { useHead } from '@unhead/react';
import { useState } from 'react';
import { useLocation, useNavigate, useParams } from 'react-router';
import { notifications } from '@mantine/notifications';
import { modals } from '@mantine/modals';
import z from 'zod';
const idSchema = z.object({
id: z.uuid(),
});
const EventPage = () => {
const [id, setId] = useState<string | null>(null);
const location = useLocation();
const query = useParams();
const navigate = useNavigate();
if (!id && idSchema.safeParse(location.state).success) {
setId(location.state.id);
} else if (!id && idSchema.safeParse(query).success) {
setId(query.id ?? null);
}
const { data: event, isLoading } = useEvent(id ?? '');
const { data: currentUser } = useMe();
const { data: user } = useUser(event?.ownerId ?? '');
const { mutateAsync: updateEvent } = useUpdateEvent();
useHead({
title: `Событие: ${event?.title ?? ''}`,
});
const eventState = event ? getEventState(event) : null;
const isOwner = currentUser?.id === event?.ownerId;
const getNextStatus = (currentStatus: EventStatus): EventStatus | null => {
switch (currentStatus) {
case EventStatus.DRAFT:
return EventStatus.PUBLISHED;
case EventStatus.PUBLISHED:
return EventStatus.CANCELLED;
case EventStatus.CANCELLED:
return EventStatus.PUBLISHED;
default:
return null;
}
};
const getStatusButtonLabel = (currentStatus: EventStatus): string => {
switch (currentStatus) {
case EventStatus.DRAFT:
return 'Опубликовать';
case EventStatus.PUBLISHED:
return 'Отменить';
case EventStatus.CANCELLED:
return 'Восстановить';
default:
return '';
}
};
const getStatusButtonIcon = (currentStatus: EventStatus) => {
switch (currentStatus) {
case EventStatus.DRAFT:
return <IconEye size={18} />;
case EventStatus.PUBLISHED:
return <IconX size={18} />;
case EventStatus.CANCELLED:
return <IconCheck size={18} />;
default:
return null;
}
};
const handleStatusChange = async () => {
if (!event) {
return;
}
const nextStatus = getNextStatus(event.status);
if (!nextStatus) {
return;
}
const now = new Date();
const startTime = new Date(event.startTime);
const isPastEvent = startTime < now;
if (event.status === EventStatus.DRAFT && isPastEvent) {
modals.openConfirmModal({
title: 'Подтверждение публикации',
children: (
<Text size="sm">
Дата события уже прошла. Событие будет помечено как завершенное. Продолжить?
</Text>
),
labels: { confirm: 'Продолжить', cancel: 'Отмена' },
confirmProps: { color: 'blue' },
onConfirm: async () => {
await performStatusChange(event, nextStatus);
},
});
return;
}
await performStatusChange(event, nextStatus);
};
const performStatusChange = async (eventData: typeof event, nextStatus: EventStatus) => {
if (!eventData) {
return;
}
try {
await updateEvent({
id: eventData.id,
event: {
...eventData,
status: nextStatus,
},
});
notifications.show({
title: 'Статус обновлен',
message: `Событие успешно ${getStatusButtonLabel(eventData.status).toLowerCase()}`,
color: 'green',
});
} catch (error) {
console.error(error);
notifications.show({
title: 'Ошибка',
message: 'Не удалось изменить статус события',
color: 'red',
});
}
};
if (isLoading) {
return (
<Stack gap="md">
<Skeleton height={60} />
<Skeleton height={400} />
</Stack>
);
}
if (!event) {
return (
<Stack gap="md" align="center" py="xl">
<Text size="xl" fw={500} c="dimmed">
Событие не найдено
</Text>
<Button leftSection={<IconArrowLeft size={16} />} onClick={() => navigate('/events')}>
Вернуться к событиям
</Button>
</Stack>
);
}
return (
<Stack gap="xl">
<Group>
<Button
variant="subtle"
leftSection={<IconArrowLeft size={16} />}
onClick={() => navigate('/events')}
>
Назад
</Button>
</Group>
<Grid>
<Grid.Col span={{ base: 12, lg: 8 }}>
<Card shadow="sm" padding="lg" radius="md" withBorder>
<Stack gap="lg">
<Group justify="space-between" align="flex-start">
<Box style={{ flex: 1 }}>
<Title order={1} mb="xs">
{event.title}
</Title>
<Group gap="xs" mb="xs">
<Badge
color={getEventStatusColor(event.status)}
variant="light"
leftSection={<IconTag size={14} />}
size="lg"
>
{getEventStatusLabel(event.status)}
</Badge>
{eventState && (
<Badge color={getEventStateColor(eventState)} variant="light" size="lg">
{getEventStateLabel(eventState)}
</Badge>
)}
</Group>
</Box>
{isOwner && getNextStatus(event.status) && (
<Button
leftSection={getStatusButtonIcon(event.status)}
onClick={handleStatusChange}
variant="light"
>
{getStatusButtonLabel(event.status)}
</Button>
)}
</Group>
<Divider />
{event.description && (
<Paper
p="md"
withBorder
radius="md"
style={{ backgroundColor: 'var(--mantine-color-gray-0)' }}
>
<Group gap="xs" mb="xs">
<IconFileText size={18} style={{ color: 'var(--mantine-color-gray-6)' }} />
<Text fw={500} size="sm" c="dimmed">
Описание
</Text>
</Group>
<Text size="md">{event.description}</Text>
</Paper>
)}
<Stack gap="md">
<Group gap="md">
<IconCalendar size={20} style={{ color: 'var(--mantine-color-blue-6)' }} />
<Box style={{ flex: 1 }}>
<Text size="sm" c="dimmed" mb={4}>
Время начала
</Text>
<Text fw={500}>{formatDateTime(event.startTime)}</Text>
</Box>
</Group>
<Group gap="md">
<IconClock size={20} style={{ color: 'var(--mantine-color-blue-6)' }} />
<Box style={{ flex: 1 }}>
<Text size="sm" c="dimmed" mb={4}>
Время окончания
</Text>
<Text fw={500}>{formatDateTime(event.endTime)}</Text>
</Box>
</Group>
<Group gap="md">
<IconUser size={20} style={{ color: 'var(--mantine-color-blue-6)' }} />
<Box style={{ flex: 1 }}>
<Text size="sm" c="dimmed" mb={4}>
Создатель
</Text>
<Text fw={500}>{user?.username ?? 'Неизвестный пользователь'}</Text>
{user?.email && (
<Text size="sm" c="dimmed">
{user.email}
</Text>
)}
</Box>
</Group>
</Stack>
<Divider />
<Group gap="xs">
<Text size="sm" c="dimmed">
Создано:
</Text>
<Text size="sm" fw={500}>
{formatDateTime(event.createdAt)}
</Text>
</Group>
</Stack>
</Card>
</Grid.Col>
<Grid.Col span={{ base: 12, lg: 4 }}>
<EventInvitees eventId={event.id} />
</Grid.Col>
</Grid>
</Stack>
);
};
EventPage.displayName = 'EventPage';
export { EventPage };

frontend/src/pages/events/ui/EventsPage.tsx
import {
useCreateEvent,
useDeleteEvent,
useUserEvents,
useInvitedEvents,
type EventRequest,
type EventResponse,
EventStatus,
EventStatusData,
} from '@/entities/event';
import { useMe } from '@/entities/user';
import { EventForm } from '@/features/event-form';
import {
formatDateTime,
getEventStatusLabel,
getEventStatusColor,
getEventState,
getEventStateLabel,
getEventStateColor,
} from '@/shared/utils';
import { IconEdit, IconTrash, IconCalendar, IconClock, IconTag } from '@tabler/icons-react';
import {
Button,
Card,
Group,
Stack,
Title,
Text,
SimpleGrid,
Skeleton,
Badge,
ActionIcon,
Tooltip,
Divider,
Box,
Select,
} from '@mantine/core';
import { modals } from '@mantine/modals';
import { notifications } from '@mantine/notifications';
import { useNavigate } from 'react-router';
import { useHead } from '@unhead/react';
import { useMemo } from 'react';
import { useQueryFilter } from '@/shared/lib/use-query-filters';
type SortOrder = 'asc' | 'desc';
const EventsPage = () => {
useHead({
title: 'События',
meta: [
{
name: 'description',
content: 'Страница событий',
},
],
});
const { data: user } = useMe();
const { data: userEvents, isLoading: isLoadingUserEvents } = useUserEvents(user?.id ?? '');
const { data: invitedEvents, isLoading: isLoadingInvitedEvents } = useInvitedEvents(user?.id ?? '');
const { mutateAsync: createEventMutation } = useCreateEvent();
const { mutateAsync: deleteEventMutation } = useDeleteEvent();
const navigate = useNavigate();
// Объединяем события пользователя и приглашенные события, убирая дубликаты
const events = useMemo(() => {
const userEventsList = userEvents ?? [];
const invitedEventsList = invitedEvents ?? [];
// Создаем Map для быстрого поиска по ID и избежания дубликатов
const eventsMap = new Map<string, EventResponse>();
// Сначала добавляем события пользователя
userEventsList.forEach(event => {
eventsMap.set(event.id, event);
});
// Затем добавляем приглашенные события (если их еще нет)
invitedEventsList.forEach(event => {
if (!eventsMap.has(event.id)) {
eventsMap.set(event.id, event);
}
});
return Array.from(eventsMap.values());
}, [userEvents, invitedEvents]);
const isLoading = isLoadingUserEvents || isLoadingInvitedEvents;
const [statusFilter, setStatusFilter] = useQueryFilter<EventStatus>({
paramName: 'status',
validValues: EventStatusData.map((s) => s.value),
});
const [sortOrder, setSortOrder] = useQueryFilter<SortOrder>({
paramName: 'sort',
validValues: ['asc', 'desc'] as const,
});
const filteredAndSortedEvents = useMemo(() => {
if (!events) return [];
let filtered = events;
// Фильтр по статусу
if (statusFilter) {
filtered = filtered.filter((event) => event.status === statusFilter);
}
// Сортировка по дате
if (sortOrder) {
filtered = [...filtered].sort((a, b) => {
const dateA = new Date(a.startTime).getTime();
const dateB = new Date(b.startTime).getTime();
return sortOrder === 'asc' ? dateA - dateB : dateB - dateA;
});
}
return filtered;
}, [events, statusFilter, sortOrder]);
const createEvent = async (event: Omit<EventRequest, 'ownerId'>) => {
try {
await createEventMutation({ ...event, ownerId: user?.id ?? '' });
notifications.show({
title: 'Событие успешно создано',
message: 'Событие успешно создано',
color: 'green',
});
} catch (error: unknown) {
console.error(error);
notifications.show({
title: 'Ошибка при создании события',
message: 'Ошибка при создании события',
color: 'red',
});
}
};
const handleCreateEvent = () => {
// navigate('/events/create');
const id = modals.open({
title: 'Добавить событие',
children: (
<EventForm
onSubmit={async (values) => {
await createEvent(values);
modals.close(id);
}}
/>
),
onSubmit: (values) => {
console.log(values);
},
});
};
const handleEditEvent = (event: EventResponse) => {
navigate(`/events/${event.id}`);
};
const handleDeleteEvent = async (event: EventResponse) => {
try {
await deleteEventMutation(event.id);
notifications.show({
title: 'Событие успешно удалено',
message: 'Событие успешно удалено',
color: 'green',
});
} catch (error: unknown) {
console.error(error);
notifications.show({
title: 'Ошибка при удалении события',
message: 'Ошибка при удалении события',
color: 'red',
});
}
};
return (
<Stack gap="md">
<Group justify="space-between">
<Title order={1}>События</Title>
<Button onClick={handleCreateEvent}>Добавить событие</Button>
</Group>
{!isLoading && events && events.length > 0 && (
<Group gap="md">
<Select
placeholder="Фильтр по статусу"
data={EventStatusData.map((status) => ({ label: status.label, value: status.value }))}
value={statusFilter}
onChange={(value) => setStatusFilter(value as EventStatus | null)}
clearable
w={200}
/>
<Select
placeholder="Сортировка по дате"
data={[
{ label: 'По возрастанию', value: 'asc' },
{ label: 'По убыванию', value: 'desc' },
]}
value={sortOrder}
onChange={(value) => setSortOrder(value as SortOrder | null)}
clearable
w={200}
/>
</Group>
)}
{isLoading &&
Array.from({ length: 5 }).map((_, index) => <Skeleton key={index} height={200} />)}
{!isLoading && events?.length === 0 && <Text>Нет событий</Text>}
{!isLoading && filteredAndSortedEvents.length === 0 && events && events.length > 0 && (
<Text>Нет событий, соответствующих выбранным фильтрам</Text>
)}
{!isLoading && filteredAndSortedEvents.length > 0 && (
<SimpleGrid
cols={{ base: 1, sm: 2, lg: 5 }}
spacing={{ base: 10, sm: 'xl' }}
verticalSpacing={{ base: 'md', sm: 'xl' }}
>
{filteredAndSortedEvents.map((event) => (
<EventCard
key={event.id}
event={event}
onEdit={() => handleEditEvent(event)}
onDelete={() => handleDeleteEvent(event)}
/>
))}
</SimpleGrid>
)}
</Stack>
);
};
type EventCardProps = {
event: EventResponse;
onEdit: () => void;
onDelete: () => void;
};
const EventCard = ({ event, onEdit, onDelete }: EventCardProps) => {
const navigate = useNavigate();
const statusColor = getEventStatusColor(event.status);
const statusLabel = getEventStatusLabel(event.status);
const eventState = getEventState(event);
const stateLabel = eventState ? getEventStateLabel(eventState) : null;
const stateColor = eventState ? getEventStateColor(eventState) : null;
const handleCardClick = (e: React.MouseEvent) => {
if ((e.target as HTMLElement).closest('button, [role="button"]')) {
return;
}
navigate(`/events/${event.id}`);
};
return (
<Card
withBorder
shadow="sm"
padding="lg"
radius="md"
style={{ cursor: 'pointer', transition: 'transform 0.2s, box-shadow 0.2s' }}
onMouseEnter={(e) => {
e.currentTarget.style.transform = 'translateY(-4px)';
e.currentTarget.style.boxShadow = 'var(--mantine-shadow-md)';
}}
onMouseLeave={(e) => {
e.currentTarget.style.transform = 'translateY(0)';
e.currentTarget.style.boxShadow = 'var(--mantine-shadow-sm)';
}}
onClick={handleCardClick}
>
<Stack gap="md">
<Group justify="space-between" align="flex-start" wrap="nowrap">
<Box style={{ flex: 1, minWidth: 0 }}>
<Title order={3} size="h4" lineClamp={2} mb="xs">
{event.title}
</Title>
<Group gap="xs" mb="xs">
<Badge
color={statusColor}
variant="light"
leftSection={<IconTag size={12} />}
size="sm"
>
{statusLabel}
</Badge>
{stateLabel && stateColor && (
<Badge color={stateColor as string} variant="light" size="sm">
{stateLabel}
</Badge>
)}
</Group>
</Box>
<Group gap={4} onClick={(e) => e.stopPropagation()}>
<Tooltip label="Редактировать">
<ActionIcon
variant="subtle"
color="blue"
onClick={(e) => {
e.stopPropagation();
onEdit();
}}
>
<IconEdit size={18} />
</ActionIcon>
</Tooltip>
<Tooltip label="Удалить">
<ActionIcon
variant="subtle"
color="red"
onClick={(e) => {
e.stopPropagation();
onDelete();
}}
>
<IconTrash size={18} />
</ActionIcon>
</Tooltip>
</Group>
</Group>
{event.description && (
<Text size="sm" c="dimmed" lineClamp={2}>
{event.description}
</Text>
)}
<Divider />
<Stack gap="xs">
<Group gap="xs" wrap="nowrap">
<IconCalendar
size={16}
style={{ color: 'var(--mantine-color-blue-6)', flexShrink: 0 }}
/>
<Text size="xs" c="dimmed" truncate>
{formatDateTime(event.startTime)}
</Text>
</Group>
<Group gap="xs" wrap="nowrap">
<IconClock
size={16}
style={{ color: 'var(--mantine-color-orange-6)', flexShrink: 0 }}
/>
<Text size="xs" c="dimmed" truncate>
До {formatDateTime(event.endTime)}
</Text>
</Group>
</Stack>
</Stack>
</Card>
);
};
EventsPage.displayName = 'EventsPage';
export { EventsPage };

frontend/src/pages/invintations/index.ts
export { InvintationsPage } from './ui/InvintationsPage';

frontend/src/pages/invintations/ui/InvintationsPage.tsx
import {
InvitationStatus,
InvitationStatusData,
useInvitations,
useUpdateInvitation,
useDeleteInvitation,
type InvitationResponse,
} from '@/entities/invitation';
import { useEvents } from '@/entities/event';
import { useMe, useUser } from '@/entities/user';
import {
Button,
Card,
Group,
Stack,
Title,
Text,
Skeleton,
Badge,
Tabs,
Select,
SimpleGrid,
ActionIcon,
Tooltip,
} from '@mantine/core';
import { IconX } from '@tabler/icons-react';
import { notifications } from '@mantine/notifications';
import { useHead } from '@unhead/react';
import { useMemo } from 'react';
import dayjs from 'dayjs';
import { useQueryFilter } from '@/shared/lib/use-query-filters';
type InvitationWithEvent = InvitationResponse & { eventTitle?: string };
const InvintationsPage = () => {
useHead({
title: 'Приглашения',
meta: [
{
name: 'description',
content: 'Страница приглашений',
},
],
});
const { data: user } = useMe();
const { data: invitations, isLoading: invitationsLoading } = useInvitations();
const { data: events, isLoading: eventsLoading } = useEvents();
const { mutateAsync: updateInvitation } = useUpdateInvitation();
const { mutateAsync: deleteInvitation } = useDeleteInvitation();
const [sentStatusFilter, setSentStatusFilter] = useQueryFilter<InvitationStatus>({
paramName: 'status',
validValues: InvitationStatusData.map((s) => s.value),
});
const isLoading = invitationsLoading || eventsLoading;
const eventsMap = useMemo(() => {
if (!events) {
return new Map();
}
return new Map(events.map((event) => [event.id, event]));
}, [events]);
const { received, sent } = useMemo(() => {
if (!invitations || !user || !eventsMap) {
return { received: [], sent: [] };
}
const receivedInvitations: InvitationWithEvent[] = [];
const sentInvitations: InvitationWithEvent[] = [];
invitations.forEach((invitation) => {
const event = eventsMap.get(invitation.eventId);
const invitationWithEvent: InvitationWithEvent = { ...invitation, eventTitle: event?.title };
if (invitation.userId === user.id) {
receivedInvitations.push(invitationWithEvent);
} else if (event?.ownerId === user.id) {
sentInvitations.push(invitationWithEvent);
}
});
return { received: receivedInvitations, sent: sentInvitations };
}, [invitations, user, eventsMap]);
const filteredSent = useMemo(() => {
if (!sentStatusFilter) {
return sent;
}
return sent.filter((invitation) => invitation.status === sentStatusFilter);
}, [sent, sentStatusFilter]);
const handleAccept = async (invitation: InvitationResponse) => {
try {
await updateInvitation({
id: invitation.id,
invitation: {
eventId: invitation.eventId,
userId: invitation.userId,
status: InvitationStatus.ACCEPTED,
},
});
notifications.show({
title: 'Приглашение принято',
message: 'Приглашение успешно принято',
color: 'green',
});
} catch (error) {
console.error(error);
notifications.show({
title: 'Ошибка',
message: 'Не удалось принять приглашение',
color: 'red',
});
}
};
const handleReject = async (invitation: InvitationResponse) => {
try {
await updateInvitation({
id: invitation.id,
invitation: {
eventId: invitation.eventId,
userId: invitation.userId,
status: InvitationStatus.REJECTED,
},
});
notifications.show({
title: 'Приглашение отклонено',
message: 'Приглашение успешно отклонено',
color: 'blue',
});
} catch (error) {
console.error(error);
notifications.show({
title: 'Ошибка',
message: 'Не удалось отклонить приглашение',
color: 'red',
});
}
};
const handleDelete = async (invitation: InvitationResponse) => {
try {
await deleteInvitation(invitation.id);
notifications.show({
title: 'Приглашение удалено',
message: 'Приглашение успешно удалено',
color: 'green',
});
} catch (error) {
console.error(error);
notifications.show({
title: 'Ошибка',
message: 'Не удалось удалить приглашение',
color: 'red',
});
}
};
return (
<Stack gap="xl">
<Title order={1}>Приглашения</Title>
{isLoading && (
<Stack gap="md">
{Array.from({ length: 3 }).map((_, index) => (
<Skeleton key={index} height={150} />
))}
</Stack>
)}
{!isLoading && (
<Tabs defaultValue="received">
<Tabs.List>
<Tabs.Tab value="received">Полученные</Tabs.Tab>
<Tabs.Tab value="sent">Отправленные</Tabs.Tab>
</Tabs.List>
<Tabs.Panel value="received" pt="md">
{received.length === 0 ? (
<Text c="dimmed">Нет полученных приглашений</Text>
) : (
<SimpleGrid cols={{ base: 1, sm: 2, lg: 3 }} spacing="md">
{received.map((invitation) => (
<InvitationCard
key={invitation.id}
invitation={invitation}
type="received"
onAccept={() => handleAccept(invitation)}
onReject={() => handleReject(invitation)}
/>
))}
</SimpleGrid>
)}
</Tabs.Panel>
<Tabs.Panel value="sent" pt="md">
<Stack gap="md">
<Group justify="space-between">
<Select
placeholder="Фильтр по статусу"
data={InvitationStatusData}
value={sentStatusFilter}
onChange={(value) => setSentStatusFilter(value as InvitationStatus | null)}
clearable
w={250}
/>
</Group>
{filteredSent.length === 0 ? (
<Text c="dimmed">Нет отправленных приглашений</Text>
) : (
<SimpleGrid cols={{ base: 1, sm: 2, lg: 3 }} spacing="md">
{filteredSent.map((invitation) => (
<InvitationCard
key={invitation.id}
invitation={invitation}
type="sent"
onDelete={() => handleDelete(invitation)}
/>
))}
</SimpleGrid>
)}
</Stack>
</Tabs.Panel>
</Tabs>
)}
</Stack>
);
};
type InvitationCardProps = {
invitation: InvitationWithEvent;
type: 'received' | 'sent';
onAccept?: () => void;
onReject?: () => void;
onDelete?: () => void;
};
const InvitationCard = ({
invitation,
type,
onAccept,
onReject,
onDelete,
}: InvitationCardProps) => {
const { data: user } = useUser(invitation.userId);
const userName = user?.username || invitation.userId.slice(0, 8);
const statusColor =
invitation.status === InvitationStatus.ACCEPTED
? 'green'
: invitation.status === InvitationStatus.REJECTED
? 'red'
: 'yellow';
const statusLabel =
invitation.status === InvitationStatus.ACCEPTED
? 'Принято'
: invitation.status === InvitationStatus.REJECTED
? 'Отклонено'
: 'Ожидает';
return (
<Card withBorder shadow="sm" padding="lg" radius="md">
<Stack gap="sm">
<Group justify="space-between" align="flex-start">
<Stack gap="xs">
<Text fw={600} size="lg">
{type === 'received' ? (
<Text fw={600} size="lg">
{userName} приглашает вас на событие{' '}
{invitation.eventTitle || `Событие ${invitation.eventId.slice(0, 8)}...`}
</Text>
) : (
<Text fw={600} size="lg">
Вы пригласили {userName} на событие{' '}
{invitation.eventTitle || `Событие ${invitation.eventId.slice(0, 8)}...`}
</Text>
)}
</Text>
<Text size="sm" c="dimmed">
Создано: {dayjs(invitation.createdAt).format('DD.MM.YYYY HH:mm')}
</Text>
</Stack>
<Stack gap="xs" align="center">
<Badge color={statusColor} variant="light">
{statusLabel}
</Badge>
{type === 'sent' && onDelete && (
<Tooltip label="Удалить приглашение">
<ActionIcon color="red" variant="subtle" onClick={onDelete}>
<IconX size={18} />
</ActionIcon>
</Tooltip>
)}
</Stack>
</Group>
{type === 'received' && invitation.status === InvitationStatus.PENDING && (
<Group>
<Button color="green" onClick={onAccept}>
Принять
</Button>
<Button color="red" variant="outline" onClick={onReject}>
Отказаться
</Button>
</Group>
)}
</Stack>
</Card>
);
};
InvintationsPage.displayName = 'InvintationsPage';
export { InvintationsPage };

frontend/src/pages/profile/index.ts
export { ProfilePage } from './ui/ProfilePage';

frontend/src/pages/profile/ui/ProfilePage.tsx
import { useMe, useLogout } from '@/entities/user';
import { useInvitations } from '@/entities/invitation';
import { useUserEvents } from '@/entities/event';
import { useUserContacts } from '@/entities/contact';
import { nameToColor, formatDateTime } from '@/shared/utils';
import { ProfileEditForm } from '@/features/profile-edit-form';
import {
Card,
Stack,
Group,
Title,
Text,
Avatar,
Badge,
Button,
Skeleton,
Divider,
Paper,
SimpleGrid,
} from '@mantine/core';
import {
IconUser,
IconMail,
IconCalendar,
IconShield,
IconEdit,
IconUsers,
IconTicket,
IconCalendarEvent,
IconLogout,
} from '@tabler/icons-react';
import { useHead } from '@unhead/react';
import { modals } from '@mantine/modals';
import { useMemo } from 'react';
import { useNavigate, Link } from 'react-router';
import { notifications } from '@mantine/notifications';
import { IconSettings } from '@tabler/icons-react';
const ProfilePage = () => {
useHead({
title: 'Профиль',
meta: [
{
name: 'description',
content: 'Страница профиля пользователя',
},
],
});
const { data: user, isLoading } = useMe();
const { data: invitations } = useInvitations();
const { data: events } = useUserEvents(user?.id ?? '');
const { data: contacts } = useUserContacts(user?.id ?? '');
const { mutateAsync: logout } = useLogout();
const navigate = useNavigate();
const stats = useMemo(() => {
if (!user) {
return { invitationsCount: 0, eventsCount: 0, contactsCount: 0 };
}
const invitationsCount = invitations?.filter((inv) => inv.userId === user.id).length ?? 0;
const eventsCount = events?.length ?? 0;
const contactsCount =
contacts?.filter(
(contact) =>
contact.status === 'ACCEPTED' &&
(contact.fromUserId === user.id || contact.toUserId === user.id),
).length ?? 0;
return { invitationsCount, eventsCount, contactsCount };
}, [user, invitations, events, contacts]);
const handleEdit = () => {
if (!user) {
return;
}
modals.open({
title: 'Редактировать профиль',
children: (
<ProfileEditForm
initialData={{ email: user.email, username: user.username }}
userId={user.id}
onSuccess={() => {
modals.closeAll();
}}
/>
),
});
};
const handleLogout = async () => {
try {
await logout();
notifications.show({
title: 'Выход выполнен',
message: 'Вы успешно вышли из аккаунта',
color: 'blue',
});
navigate('/login', { replace: true });
} catch (error) {
console.error('Logout error:', error);
notifications.show({
title: 'Ошибка',
message: 'Не удалось выйти из аккаунта',
color: 'red',
});
}
};
if (isLoading) {
return (
<Stack gap="xl">
<Title order={1}>Профиль</Title>
<Card withBorder shadow="sm" padding="xl" radius="md">
<Stack gap="md">
<Group>
<Skeleton height={100} circle />
<Stack gap="xs" style={{ flex: 1 }}>
<Skeleton height={28} width="60%" />
<Skeleton height={20} width="40%" />
</Stack>
</Group>
<Divider />
<Skeleton height={20} />
<Skeleton height={20} />
<Skeleton height={20} />
</Stack>
</Card>
</Stack>
);
}
if (!user) {
return (
<Stack gap="xl">
<Title order={1}>Профиль</Title>
<Card withBorder shadow="sm" padding="xl" radius="md">
<Text c="dimmed">Не удалось загрузить данные профиля</Text>
</Card>
</Stack>
);
}
return (
<Stack gap="xl">
<Group justify="space-between" align="center">
<Title order={1}>Профиль</Title>
<Group gap="md">
{user.role === 'ADMIN' && (
<Button
component={Link}
to="/admin/users"
leftSection={<IconSettings size={18} />}
variant="light"
>
Управление пользователями
</Button>
)}
<Button leftSection={<IconEdit size={18} />} onClick={handleEdit}>
Редактировать
</Button>
<Button
leftSection={<IconLogout size={18} />}
variant="outline"
color="red"
onClick={handleLogout}
>
Выйти
</Button>
</Group>
</Group>
<Card withBorder shadow="sm" padding="xl" radius="md">
<Stack gap="xl">
<Group gap="xl" align="flex-start">
<Avatar size={120} radius="md" name={user.username} color={nameToColor(user.username)}>
{user.username.slice(0, 2).toUpperCase()}
</Avatar>
<Stack gap="xs" style={{ flex: 1 }}>
<Group gap="md" align="center">
<Title order={2}>{user.username}</Title>
<Badge color={user.role === 'ADMIN' ? 'red' : 'blue'} variant="light">
{user.role === 'ADMIN' ? 'Администратор' : 'Пользователь'}
</Badge>
</Group>
<Text c="dimmed" size="sm">
ID: {user.id}
</Text>
</Stack>
</Group>
<Divider />
<SimpleGrid cols={{ base: 1, sm: 2 }} spacing="lg">
<Paper p="md" withBorder radius="md">
<Group gap="md">
<IconMail size={24} stroke={1.5} style={{ color: 'var(--mantine-color-blue-6)' }} />
<Stack gap={4}>
<Text size="xs" c="dimmed" tt="uppercase" fw={600}>
Email
</Text>
<Text size="md" fw={500}>
{user.email}
</Text>
</Stack>
</Group>
</Paper>
<Paper p="md" withBorder radius="md">
<Group gap="md">
<IconUser
size={24}
stroke={1.5}
style={{ color: 'var(--mantine-color-green-6)' }}
/>
<Stack gap={4}>
<Text size="xs" c="dimmed" tt="uppercase" fw={600}>
Имя пользователя
</Text>
<Text size="md" fw={500}>
{user.username}
</Text>
</Stack>
</Group>
</Paper>
<Paper p="md" withBorder radius="md">
<Group gap="md">
<IconCalendar
size={24}
stroke={1.5}
style={{ color: 'var(--mantine-color-orange-6)' }}
/>
<Stack gap={4}>
<Text size="xs" c="dimmed" tt="uppercase" fw={600}>
Дата регистрации
</Text>
<Text size="md" fw={500}>
{formatDateTime(user.createdAt)}
</Text>
</Stack>
</Group>
</Paper>
<Paper p="md" withBorder radius="md">
<Group gap="md">
<IconShield
size={24}
stroke={1.5}
style={{ color: 'var(--mantine-color-red-6)' }}
/>
<Stack gap={4}>
<Text size="xs" c="dimmed" tt="uppercase" fw={600}>
Роль
</Text>
<Badge color={user.role === 'ADMIN' ? 'red' : 'blue'} variant="light" size="lg">
{user.role === 'ADMIN' ? 'Администратор' : 'Пользователь'}
</Badge>
</Stack>
</Group>
</Paper>
</SimpleGrid>
<Divider />
<Title order={3}>Статистика</Title>
<SimpleGrid cols={{ base: 1, sm: 3 }} spacing="lg">
<Paper p="md" withBorder radius="md" style={{ textAlign: 'center' }}>
<Stack gap="xs" align="center">
<IconTicket
size={32}
stroke={1.5}
style={{ color: 'var(--mantine-color-blue-6)' }}
/>
<Text size="xl" fw={700}>
{stats.invitationsCount}
</Text>
<Text size="sm" c="dimmed">
Приглашений
</Text>
</Stack>
</Paper>
<Paper p="md" withBorder radius="md" style={{ textAlign: 'center' }}>
<Stack gap="xs" align="center">
<IconCalendarEvent
size={32}
stroke={1.5}
style={{ color: 'var(--mantine-color-green-6)' }}
/>
<Text size="xl" fw={700}>
{stats.eventsCount}
</Text>
<Text size="sm" c="dimmed">
Событий
</Text>
</Stack>
</Paper>
<Paper p="md" withBorder radius="md" style={{ textAlign: 'center' }}>
<Stack gap="xs" align="center">
<IconUsers
size={32}
stroke={1.5}
style={{ color: 'var(--mantine-color-orange-6)' }}
/>
<Text size="xl" fw={700}>
{stats.contactsCount}
</Text>
<Text size="sm" c="dimmed">
Контактов
</Text>
</Stack>
</Paper>
</SimpleGrid>
</Stack>
</Card>
</Stack>
);
};
ProfilePage.displayName = 'ProfilePage';
export { ProfilePage };

frontend/src/shared/api/client.ts
import { API_URL } from '@/shared/config';
import { tokenStorage } from '@/shared/lib/token';
class ApiClient {
private isRefreshing = false;
private refreshPromise: Promise<string> | null = null;
public constructor(private readonly baseUrl: string) {}
private getHeaders(): Record<string, string> {
const headers: Record<string, string> = {
'Content-Type': 'application/json',
};
const token = tokenStorage.get();
if (token) {
headers['Authorization'] = `Bearer ${token}`;
}
return headers;
}
private async refreshToken(): Promise<string> {
if (this.isRefreshing && this.refreshPromise) {
return this.refreshPromise;
}
this.isRefreshing = true;
this.refreshPromise = fetch(`${this.baseUrl}/auth/refresh`, {
method: 'POST',
headers: {
'Content-Type': 'application/json',
},
credentials: 'include',
})
.then(async (response) => {
if (!response.ok) {
tokenStorage.remove();
throw new Error('Failed to refresh token');
}
const data = await response.json();
if (data.accessToken) {
tokenStorage.set(data.accessToken);
return data.accessToken;
}
throw new Error('No access token in refresh response');
})
.catch((error) => {
tokenStorage.remove();
throw error;
})
.finally(() => {
this.isRefreshing = false;
this.refreshPromise = null;
});
return this.refreshPromise;
}
private async requestWithAuth<T>(url: string, options: RequestInit, retry = true): Promise<T> {
const response = await fetch(`${this.baseUrl}${url}`, {
...options,
headers: this.getHeaders(),
credentials: 'include',
});
if (response.status === 401 && retry) {
try {
await this.refreshToken();
return this.requestWithAuth<T>(url, options, false);
} catch (error) {
tokenStorage.remove();
throw error;
}
}
if (!response.ok) {
const error = new Error(`HTTP error! status: ${response.status}`);
(error as Error & { status: number }).status = response.status;
throw error;
}
// Статусы без тела ответа (204 No Content, 205 Reset Content и т.д.)
if (response.status === 204 || response.status === 205) {
return null as T;
}
// Проверяем наличие контента перед парсингом JSON
const contentType = response.headers.get('content-type');
const contentLength = response.headers.get('content-length');
if (!contentType?.includes('application/json') || contentLength === '0') {
return null as T;
}
// Пытаемся получить текст, чтобы проверить, не пустой ли ответ
const text = await response.text();
if (!text || text.trim() === '') {
return null as T;
}
try {
return JSON.parse(text) as T;
} catch {
// Если не удалось распарсить JSON, возвращаем null
return null as T;
}
}
public async get<T>(url: string): Promise<T> {
return this.requestWithAuth<T>(url, {
method: 'GET',
});
}
public async post<T>(url: string, data: unknown): Promise<T> {
return this.requestWithAuth<T>(url, {
method: 'POST',
body: JSON.stringify(data),
});
}
public async put<T>(url: string, data: unknown): Promise<T> {
return this.requestWithAuth<T>(url, {
method: 'PUT',
body: JSON.stringify(data),
});
}
public async delete<T>(url: string): Promise<T> {
return this.requestWithAuth<T>(url, {
method: 'DELETE',
});
}
}
export const apiClient = new ApiClient(API_URL);

frontend/src/shared/api/index.ts
export { apiClient } from './client';

frontend/src/shared/config/constants.ts
const API_URL = import.meta.env.VITE_API_URL;
export { API_URL };

frontend/src/shared/config/index.ts
export { queryClient } from './query';
export { API_URL } from './constants';

frontend/src/shared/config/query.ts
import { QueryClient } from '@tanstack/react-query';
const queryClient = new QueryClient({
defaultOptions: {
queries: {
refetchOnWindowFocus: false,
retry: false,
},
},
});
export { queryClient };

frontend/src/shared/lib/token-refresh.ts
import { tokenStorage } from './token';
const TOKEN_CHECK_INTERVAL = 14 * 60 * 1000; // 14 минут (токен живет 15 минут)
let refreshIntervalId: number | null = null;
const decodeToken = (token: string): { exp?: number } | null => {
try {
const payload = token.split('.')[1];
const decoded = JSON.parse(atob(payload));
return decoded;
} catch {
return null;
}
};
const isTokenExpiringSoon = (token: string): boolean => {
const decoded = decodeToken(token);
if (!decoded || !decoded.exp) return true;
const expirationTime = decoded.exp * 1000; // конвертируем в миллисекунды
const now = Date.now();
const timeUntilExpiration = expirationTime - now;
// Обновляем если до истечения осталось меньше 2 минут
return timeUntilExpiration < 2 * 60 * 1000;
};
export const startTokenRefresh = (refreshFn: () => Promise<void>) => {
if (refreshIntervalId) {
clearInterval(refreshIntervalId);
}
const checkAndRefresh = async () => {
const token = tokenStorage.get();
if (!token) {
stopTokenRefresh();
return;
}
if (isTokenExpiringSoon(token)) {
try {
await refreshFn();
} catch (error) {
console.error('Failed to refresh token:', error);
tokenStorage.remove();
stopTokenRefresh();
}
}
};
// Проверяем сразу при старте
checkAndRefresh();
// Затем проверяем каждые 14 минут
refreshIntervalId = setInterval(checkAndRefresh, TOKEN_CHECK_INTERVAL);
};
export const stopTokenRefresh = () => {
if (refreshIntervalId) {
clearInterval(refreshIntervalId);
refreshIntervalId = null;
}
};

frontend/src/shared/lib/token.ts
const ACCESS_TOKEN_KEY = 'accessToken';
class TokenStorage {
constructor(private readonly storageKey: string) {}
get(): string | null {
if (typeof window === 'undefined') {
return null;
}
return localStorage.getItem(this.storageKey);
}
set(token: string): void {
if (typeof window === 'undefined') {
return;
}
localStorage.setItem(this.storageKey, token);
}
remove(): void {
if (typeof window === 'undefined') {
return;
}
localStorage.removeItem(this.storageKey);
}
has(): boolean {
return this.get() !== null;
}
}
export const tokenStorage = new TokenStorage(ACCESS_TOKEN_KEY);

frontend/src/shared/lib/use-query-filters.ts
import { useSearchParams } from 'react-router';
import { useCallback, useMemo } from 'react';
type UseQueryFiltersOptions<T extends string> = {
paramName: string;
defaultValue?: T | null;
validValues?: readonly T[];
};
/**
* Хук для работы с фильтрами через query параметры URL
* @param options - Опции для настройки фильтра
* @returns Объект с текущим значением фильтра и функцией для его обновления
*/
export const useQueryFilter = <T extends string>({
paramName,
defaultValue = null,
validValues,
}: UseQueryFiltersOptions<T>) => {
const [searchParams, setSearchParams] = useSearchParams();
const value = useMemo(() => {
const paramValue = searchParams.get(paramName);
if (!paramValue) return defaultValue;
// Если указаны валидные значения, проверяем соответствие
if (validValues && !validValues.includes(paramValue as T)) {
return defaultValue;
}
return paramValue as T;
}, [searchParams, paramName, defaultValue, validValues]);
const setValue = useCallback(
(newValue: T | null) => {
setSearchParams((prev) => {
const newParams = new URLSearchParams(prev);
if (newValue === null || newValue === defaultValue) {
newParams.delete(paramName);
} else {
newParams.set(paramName, newValue);
}
return newParams;
});
},
[setSearchParams, paramName, defaultValue],
);
return [value, setValue] as const;
};

frontend/src/shared/lib/use-token-refresh.ts
import { useEffect } from 'react';
import { startTokenRefresh, stopTokenRefresh } from './token-refresh';
import { useRefresh } from '@/entities/user';
export const useTokenRefresh = () => {
const { mutateAsync: refresh } = useRefresh();
useEffect(() => {
const refreshFn = async () => {
await refresh();
};
startTokenRefresh(refreshFn);
return () => {
stopTokenRefresh();
};
}, [refresh]);
};

frontend/src/shared/ui/avatar/index.tsx
import { Avatar as MantineAvatar, UnstyledButton } from '@mantine/core';
import { nameToColor } from '@/shared/utils';
import { Link } from 'react-router';
const Avatar = ({ name }: { name: string }) => {
return (
<Link to="/profile">
<UnstyledButton>
<MantineAvatar name={name} color={nameToColor(name)} />
</UnstyledButton>
</Link>
);
};
export { Avatar };

frontend/src/shared/ui/header/index.ts
export { Header } from './ui/Header';

frontend/src/shared/ui/header/ui/Header.tsx
import { AppShell, Box, Burger, Group, Image, Tooltip } from '@mantine/core';
import { Link } from 'react-router';
import { Avatar } from '@shared/ui/avatar';
import { Links } from '@shared/ui/links';
const Logo = () => {
return (
<Link to="/">
<Image
src="/logo.png"
alt="Logo"
width={32}
height={32}
style={{
objectRepeat: 'no-repeat',
}}
fit="contain"
maw="50px"
/>
</Link>
);
};
const DefaultHeader = () => {
return (
<header className="flex items-center justify-between border-b border-gray-700 rounded-md">
<Group px="md" py="5px">
<Logo />
</Group>
</header>
);
};
DefaultHeader.displayName = 'DefaultHeader';
type AppHeaderProps = {
opened: boolean;
toggle: () => void;
name: string;
};
const AppHeader = ({ opened, toggle, name }: AppHeaderProps) => {
return (
<AppShell.Header>
<Group h="100%" px="md" justify="space-between">
<Group>
<Burger opened={opened} onClick={toggle} hiddenFrom="sm" size="sm" />
<Logo />
</Group>
<Group visibleFrom="sm" gap="md">
<Links dir="row" gap={10} />
<Tooltip label="Профиль">
<Box>
<Avatar name={name} />
</Box>
</Tooltip>
</Group>
</Group>
</AppShell.Header>
);
};
const Header = {
Default: DefaultHeader,
App: AppHeader,
};
AppHeader.displayName = 'AppHeader';
export { Header };

frontend/src/shared/ui/links/index.tsx
import { Group, UnstyledButton } from '@mantine/core';
import { Link } from 'react-router';
type LinksProps = {
dir: 'row' | 'col';
gap: number;
};
const Links = ({ dir, gap }: LinksProps) => {
return (
<Group dir={dir} gap={gap}>
<Link to="/events">
<UnstyledButton>События</UnstyledButton>
</Link>
<Link to="/invitations">
<UnstyledButton>Приглашения</UnstyledButton>
</Link>
<Link to="/contacts">
<UnstyledButton>Контакты</UnstyledButton>
</Link>
</Group>
);
};
export { Links };

frontend/src/shared/ui/ProtectedRoute.tsx
import { Navigate } from 'react-router';
import { useMe, useRefresh } from '@/entities/user';
import { tokenStorage } from '@/shared/lib/token';
import { Loader, Center } from '@mantine/core';
import { useEffect, useState, type PropsWithChildren } from 'react';
export const ProtectedRoute = ({ children }: PropsWithChildren) => {
const hasToken = tokenStorage.has();
const { data: user, isLoading, isError } = useMe();
const { mutateAsync: refresh } = useRefresh();
const [isRefreshing, setIsRefreshing] = useState(false);
// При загрузке проверяем, есть ли refresh token в cookie
// Если есть, но нет access token - пытаемся обновить
useEffect(() => {
const checkAndRefreshToken = async () => {
if (!hasToken && !isRefreshing) {
setIsRefreshing(true);
try {
await refresh();
} catch (error: unknown) {
console.debug('No valid refresh token', error);
} finally {
setIsRefreshing(false);
}
}
};
checkAndRefreshToken();
}, [hasToken, isRefreshing, refresh]);
// Если нет токена и не обновляем, редиректим
if (!hasToken && !isRefreshing) {
return <Navigate to="/login" replace />;
}
// Пока проверяем авторизацию или обновляем токен, показываем loader
if (isLoading || isRefreshing) {
return (
<Center h="100vh">
<Loader size="lg" />
</Center>
);
}
// Если ошибка авторизации (401), редиректим на логин
if (isError || !user) {
tokenStorage.remove();
return <Navigate to="/login" replace />;
}
// Если авторизован, показываем контент
return <>{children}</>;
};

frontend/src/shared/ui/PublicRoute.tsx
import { Navigate } from 'react-router';
import { useMe } from '@/entities/user';
import { tokenStorage } from '@/shared/lib/token';
import type { PropsWithChildren } from 'react';
export const PublicRoute = ({ children }: PropsWithChildren) => {
const hasToken = tokenStorage.has();
const { data: user, isLoading } = useMe();
if (hasToken && user && !isLoading) {
return <Navigate to="/" replace />;
}
return <>{children}</>;
};

frontend/src/shared/utils/colors.ts
function hashString(str: string): number {
let hash = 0;
for (let i = 0; i < str.length; i++) {
hash = str.charCodeAt(i) + ((hash << 5) - hash);
}
return hash;
}
function nameToColor(name: string): string {
const hash = hashString(name);
const hue = Math.abs(hash) % 360;
return `hsl(${hue}, 60%, 70%)`; // светлый фон
}
export { nameToColor };

frontend/src/shared/utils/date.ts
import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc';
import 'dayjs/locale/ru';
dayjs.extend(utc);
export const formatDateTime = (date: Date | string): string => {
const localDate = dayjs(date).locale('ru');
const utcDate = dayjs.utc(date).locale('ru');
const localFormatted = localDate.format('D MMMM YYYY, HH:mm');
const utcFormatted = utcDate.format('D MMMM YYYY, HH:mm');
// Если время отличается, показываем UTC в скобках
const localTimeStr = localDate.format('YYYY-MM-DD HH:mm');
const utcTimeStr = utcDate.format('YYYY-MM-DD HH:mm');
if (localTimeStr !== utcTimeStr) {
return `${localFormatted} (UTC: ${utcFormatted})`;
}
return localFormatted;
};

frontend/src/shared/utils/event-status.ts
import { EventStatus, type EventResponse } from '@/entities/event';
import { InvitationStatus } from '@/entities/invitation';
export const enum EventState {
UPCOMING = 'UPCOMING',
ONGOING = 'ONGOING',
FINISHED = 'FINISHED',
}
export const getEventStatusLabel = (status: EventStatus): string => {
switch (status) {
case EventStatus.PUBLISHED:
return 'Опубликовано';
case EventStatus.DRAFT:
return 'Черновик';
case EventStatus.CANCELLED:
return 'Отменено';
default:
return status;
}
};
export const getEventStatusColor = (status: EventStatus): string => {
switch (status) {
case EventStatus.PUBLISHED:
return 'green';
case EventStatus.DRAFT:
return 'gray';
case EventStatus.CANCELLED:
return 'red';
default:
return 'blue';
}
};
export const getEventState = (event: EventResponse): EventState | null => {
if (event.status === EventStatus.DRAFT || event.status === EventStatus.CANCELLED) {
return null;
}
const now = new Date();
const startTime = new Date(event.startTime);
const endTime = new Date(event.endTime);
if (now < startTime) {
return EventState.UPCOMING;
} else if (now >= startTime && now < endTime) {
return EventState.ONGOING;
} else {
return EventState.FINISHED;
}
};
export const getEventStateLabel = (state: EventState | null): string => {
if (!state) return '';
switch (state) {
case EventState.UPCOMING:
return 'Предстоящее';
case EventState.ONGOING:
return 'Идет';
case EventState.FINISHED:
return 'Завершено';
default:
return '';
}
};
export const getEventStateColor = (state: EventState | null): string => {
if (!state) return 'gray';
switch (state) {
case EventState.UPCOMING:
return 'blue';
case EventState.ONGOING:
return 'green';
case EventState.FINISHED:
return 'orange';
default:
return 'gray';
}
};
export const getStatusColor = (status: InvitationStatus) => {
switch (status) {
case InvitationStatus.ACCEPTED:
return 'green';
case InvitationStatus.REJECTED:
return 'red';
case InvitationStatus.PENDING:
return 'yellow';
default:
return 'gray';
}
};
export const getStatusLabel = (status: InvitationStatus) => {
switch (status) {
case InvitationStatus.ACCEPTED:
return 'Принято';
case InvitationStatus.REJECTED:
return 'Отклонено';
case InvitationStatus.PENDING:
return 'Ожидает';
default:
return status;
}
};

frontend/src/shared/utils/index.ts
export { nameToColor } from './colors';
export { formatDateTime } from './date';
export * from './event-status';

frontend/src/widgets/app-layout/index.ts
export { AppLayout } from './ui/AppLayout';

frontend/src/widgets/app-layout/ui/AppLayout.tsx
import { Header } from '@/shared/ui/header';
import { AppShell, Stack, UnstyledButton, Group, Box, Tooltip } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { Outlet, Link } from 'react-router';
import { useTokenRefresh } from '@/shared/lib/use-token-refresh';
import { useMe } from '@/entities/user';
import { Avatar } from '@/shared/ui/avatar';
const AppLayout = () => {
const [opened, { toggle }] = useDisclosure();
useTokenRefresh();
const { data: user } = useMe();
return (
<AppShell
header={{ height: 60 }}
navbar={{ width: 300, breakpoint: 'sm', collapsed: { desktop: true, mobile: !opened } }}
padding="md"
>
<Header.App opened={opened} toggle={toggle} name={user?.username || ''} />
<AppShell.Navbar py="md" px="md">
<Stack gap="md">
<Link to="/events">
<UnstyledButton w="100%" style={{ textAlign: 'left' }}>
События
</UnstyledButton>
</Link>
<Link to="/invitations">
<UnstyledButton w="100%" style={{ textAlign: 'left' }}>
Приглашения
</UnstyledButton>
</Link>
<Link to="/contacts">
<UnstyledButton w="100%" style={{ textAlign: 'left' }}>
Контакты
</UnstyledButton>
</Link>
<Link to="/profile">
<Group
gap="xs"
mt="md"
pt="md"
style={{ borderTop: '1px solid var(--mantine-color-gray-3)' }}
>
<Tooltip label="Профиль">
<Box>
<Avatar name={user?.username || ''} />
</Box>
</Tooltip>
<UnstyledButton style={{ textAlign: 'left' }}>Профиль</UnstyledButton>
</Group>
</Link>
</Stack>
</AppShell.Navbar>
<AppShell.Main>
<Outlet />
</AppShell.Main>
</AppShell>
);
};
AppLayout.displayName = 'AppLayout';
export { AppLayout };

frontend/src/widgets/default-layout/index.ts
export { DefaultLayout } from './ui/DefaultLayout';

frontend/src/widgets/default-layout/ui/DefaultLayout.tsx
import { Header } from '@/shared/ui/header';
import { Outlet } from 'react-router';
const DefaultLayout = () => {
return (
<div className="min-h-screen flex flex-col">
<Header.Default />
<main className="flex-1 flex flex-col items-center justify-center">
<Outlet />
</main>
</div>
);
};
DefaultLayout.displayName = 'DefaultLayout';
export { DefaultLayout };

frontend/tsconfig.app.json
{
"compilerOptions": {
"tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
"target": "ES2022",
"useDefineForClassFields": true,
"lib": ["ES2022", "DOM", "DOM.Iterable"],
"module": "ESNext",
"types": ["vite/client"],
"skipLibCheck": true,
/* Bundler mode */
"moduleResolution": "bundler",
"allowImportingTsExtensions": true,
"verbatimModuleSyntax": true,
"moduleDetection": "force",
"noEmit": true,
"jsx": "react-jsx",
/* Linting */
"strict": true,
"noUnusedLocals": true,
"noUnusedParameters": true,
"erasableSyntaxOnly": false,
"noFallthroughCasesInSwitch": true,
"noUncheckedSideEffectImports": true,
/* Paths */
"baseUrl": ".",
"paths": {
"@/*": ["./src/*"],
"@pages/*": ["./src/pages/*"],
"@app/*": ["./src/app/*"],
"@widgets/*": ["./src/widgets/*"],
"@features/*": ["./src/features/*"],
"@entities/*": ["./src/entities/*"],
"@shared/*": ["./src/shared/*"]
}
},
"include": ["src"]
}

frontend/tsconfig.json
{
"files": [],
"references": [{ "path": "./tsconfig.app.json" }, { "path": "./tsconfig.node.json" }],
"compilerOptions": {
"baseUrl": ".",
"paths": {
"@/*": ["./src/*"],
"@pages/*": ["./src/pages/*"],
"@app/*": ["./src/app/*"],
"@widgets/*": ["./src/widgets/*"],
"@features/*": ["./src/features/*"],
"@entities/*": ["./src/entities/*"],
"@shared/*": ["./src/shared/*"]
}
}
}

frontend/tsconfig.node.json
{
"compilerOptions": {
"tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
"target": "ES2023",
"lib": ["ES2023"],
"module": "ESNext",
"types": ["node"],
"skipLibCheck": true,
/* Bundler mode */
"moduleResolution": "bundler",
"allowImportingTsExtensions": true,
"verbatimModuleSyntax": true,
"moduleDetection": "force",
"noEmit": true,
/* Linting */
"strict": true,
"noUnusedLocals": true,
"noUnusedParameters": true,
"erasableSyntaxOnly": false,
"noFallthroughCasesInSwitch": true,
"noUncheckedSideEffectImports": true
},
"include": ["vite.config.ts"]
}

frontend/vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react-swc';
import path from 'path';
import tailwindcss from '@tailwindcss/vite';
// https://vite.dev/config/
export default defineConfig({
plugins: [react(), tailwindcss()],
resolve: {
alias: {
'@': path.resolve(__dirname, './src'),
'@pages': path.resolve(__dirname, './src/pages'),
'@app': path.resolve(__dirname, './src/app'),
'@widgets': path.resolve(__dirname, './src/widgets'),
'@features': path.resolve(__dirname, './src/features'),
'@entities': path.resolve(__dirname, './src/entities'),
'@shared': path.resolve(__dirname, './src/shared'),
},
},
});

package.json
{
"dependencies": {
"@tabler/icons-react": "^3.36.0"
},
"devDependencies": {
"@eslint/js": "^9.39.2",
"@types/node": "^25.0.3",
"eslint": "^9.39.2",
"eslint-config-mantine": "^4.0.3",
"eslint-plugin-jsx-a11y": "^6.10.2",
"eslint-plugin-react": "^7.37.5",
"prettier": "^3.7.4",
"typescript": "^5.9.3",
"typescript-eslint": "^8.50.0",
"tsx": "^4.19.2"
},
"scripts": {
"format": "npx prettier --write .",
"dev": "cd frontend && bun dev",
"generate-listing": "bun run generate-code-listing.ts"
}
}